<!-- 
 ``The contents of this file are subject to the Erlang Public License,
 Version 1.1, (the "License"); you may not use this file except in
 compliance with the License. You should have received a copy of the
 Erlang Public License along with this software. If not, it can be
 retrieved via the world wide web at http://www.erlang.org/.
 
 Software distributed under the License is distributed on an "AS IS"
 basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 the License for the specific language governing rights and limitations
 under the License.
 
 The Initial Developer of the Original Code is Ericsson Utvecklings AB.
 Portions created by Ericsson are Copyright 1999, Ericsson Utvecklings
 AB. All Rights Reserved.''
 
     $Id$
-->
<!-- Generated by Harlequin WebMaker 2.2.3 (24-Apr-1996)
LispWorks 3.2.2 -->
<HTML> <HEAD>
<TITLE>GSB</TITLE>
</HEAD>
<BODY bgcolor=white>
<A NAME=HEADING1></A>
<P>
<A NAME=HEADING1-0></A>
<H2>Appendix  A -  User's Manual For GSB</H2>
<HR>
 GSB is a tool to help you build graphical user interfaces (GUI) for Erlang/GS quick and easy. During the construction of your GUI you will not have to write any GS commands, and you do not have to compile an Erlang program for every change you make. <P>
 The result of a GSB session is a resource file, which contains information about the GUI. This resource file can be read by GSB and the run-time module <CODE>gsb_run,</CODE> which is called from the Erlang program that wants to use the GUI. <P>
<A NAME=HEADING1-3></A>
<H2>A.1   Main window</H2>
<HR>
 The main window consists of three parts, menu, toolbox and hierarchy. <P>
 <img SRC="user_main.gif" border=0></a>
 <P>
FIGURE 1.  Main menu with the toolbox to the left and the hierarchy to the right.<P>
<A NAME=HEADING1-8></A>
<H3>A.1.1   <A NAME=MARKER-9-1></A>Menu</H3>
 There are four menues<P>
 The <B>file menu</B> handles projects. A project is a GUI with at least one window and one resource file. GSB can have several projects open at the same time. The menus "Save Project","Save Project as" and "Close Project" each has a cascade menu, where the loaded projects are listed. Select the project you want to save, save as or close.<P>
 From the <B>edit menu</B> you can cut, copy, delete or paste widgets. To cut, copy or delete widgets, mark the widgets in the draw area or in the hierarchy and select action. When you want to paste the contents of the clipboard buffer, select paste and click in the draw area where you want the result. This functionality is also present on popup-menus in the draw area.<P>
 The <B>toolbox menu</B> manages the toolbox. The toolbox can be saved, and new widgets can be imported. If there exists a widget with the same name as an imported one, the old values be overwritten.<P>
 The <B>window menu</B> displays all windows that belong to GSB. When selected, the window will appear, or be opened if it was iconified.<P>
<A NAME=HEADING1-14></A>
<H3>A.1.2   Toolbox</H3>
 From the toolbox you select the next widget to be created by clicking in the listbox. The  next time you click in a draw window, that widget will be created. All widgets have default values, written in the toolbox resource files. By doubleclicking in the toolbox, these values can then be edited in the Option window. To save the toolbox default values, select Toolbox/save toolbox.<P>
<A NAME=HEADING1-16></A>
<H3>A.1.3   Hierarchy</H3>
 The hierarchy displays all created widgets in a tree-like style. It is possible to compress and expand nodes that have children. A compressed node is marked with a '+' sign and an expanded node or a node without children is marked with a '-' sign. It is also possible to mark widgets in the hierarchy, the corresponding widget in the draw area will then be marked. If the shift button is pressed, it is possible to mark several widgets at the same time.<P>
<A NAME=HEADING1-18></A>
<H2>A.2   Draw area</H2>
<HR>
 The draw area is where you construct and redefine the GUI for your application.<P>
  <img SRC="user_draw.gif" border=0></a>
 <P>
FIGURE 2.  A sample draw window of the file dialogue used in GSB with
the popup-menu. The window is marked.<P>
 Widgets are selected with the left mouse button, a selected widget is marked with a yellow rectangle. To mark several widgets simultaneously, press the 'shift' button and mark the widgets. The right mouse button shows the popup-menu.<P>
 The cut, copy, paste and delete functionality in the popup-menu is the same as in the main menu (<A HREF=#MARKER-9-1>Section A.1.1</A>). "Center" and "Align" manipulates the marked widgets with respect to position, "Shrink to smallest" and "Grow to biggest" manipulates the marked widgets with respect to size.<P>
 The "Grid" menu has two options, "Snap" and "Don't Snap". "Snap"
 means that the widgets will be placed only on x and y values that are
 multiples of ten. <P>
<H3>A.1.3   The Menu editor</H3>
The menu editor is an editor for creation of menues. A menu consists
of a menubar, menubuttons and pull-down menues. A pull-down menu can
contain menuitems of different styles where "menuitem_cascade" are
used to create submenus. The menu widgets are selected the same way as
ordinary widgets, but menubuttons and menuitem_cascades can also
hide/display their menues if they are clicked on twice. Menu widgets can
be cut/copied/deleted and pasted, but not moved or resized.  
<A NAME=HEADING1-26></A>
<H2>A.3   Option window</H2>
<HR>
 The option window views all options for the marked widgets.<P>
  <img SRC="user_option.gif" border=0></a><P>
FIGURE 3.  The option window with the property "align" marked and supporting popup-menu.<P>
 The option window has two modes, properties and events mode. The mode is switched by clicking on either radio-button. A option is selected with the left mouse-button (the white row "Align" in Figure 3). There are several types of input possible to options<P>
<UL>
<LI>An external editor, like the color editor.<P>
<LI>A popup-menu with list of atoms.<P>
<LI>An integer value, entered in the entry field.<P>
<LI>A string or a tuple, entered in the entry field.<P>
</UL>
 Popup-menus, or external editors are invoked by clicking on a marked option width the left mouse-button.<P>
 When two or more widgets are marked from the draw area or hierarchy, the values are compared. An option that exist in all marked widgets are then shown in the option window, and an option that does not have the same value in all marked widget are shown with an italic and bold font. The value shown is the value of the first marked widget. When editing a value, all marked widgets will be affected.<P>
<A NAME=HEADING1-37></A>
<H2>A.4   Connection to Erlang</H2>
<HR>
 The resource file produced by GSB is a text-file with Erlang tuples. These tuples can be parsed at runtime by the <CODE>gsb_run</CODE> module, or be compiled to an Erlang program. <P>
<A NAME=HEADING1-39></A>
<H3>A.4.1   Starting a resource file</H3>
 A resource file is started with the command <CODE>gsb_run:start(GS, Filename)</CODE> where <CODE>GS</CODE> is a gs object that will be the the parent for the top widget in the resource file, and <CODE>Filename</CODE> is an absolute path to the resource file. <P>
<PRE>
-module(foo).
-export([start/1, init/1]).

start(GS) -&gt;
  spawn(gsb_1,init,[GS]).

init(GS) -&gt;
  gsb_run:start(GS, "foo.rc"),
  loop().
</PRE>
Example 1.   How to start a resource file<P>
<A NAME=HEADING1-51></A>
<H3>A.4.2   Generating Erlang code from resource file</H3>
  Instead of having resource files, it is possible to compile resource files to Erlang programs. This is a good step to take when you want to make your programs available for other programmers or need speed improvements. You then compile the current version of your GUI, and call a module instead of reading a resource file. <P>
<PRE>
-module(bar).
-export([start/1, init/1]).

start(GS) -&gt;
  spawn(gsb_2, init, [GS]).

init(GS) -&gt;
  gsb_run:start(GS,bar),
  loop().
</PRE>
Example 2.   How to start a compiled resource file<P>
 A resource file is compiled by the call <CODE>gsb_run:rc2erl(Module) </CODE>where file and <CODE>Module</CODE> is the module that should be produced (i.e there is a resource file namned "Module.rc"). The result will be a Erlang module <CODE>Module</CODE> + "_ui". The extension "_ui" is added to differentiate the GUI module from the logic module.<P>
<A NAME=HEADING1-64></A>
<H2>A.5   Softwidgets</H2>
<HR>
 A softwidget is a combination of several widgets that together with logic (as an subprocess) forms an entity. Examples of possible softwidgets are different dialog-boxes, a frame with ok, cancel and help buttons, etc. <P>
<A NAME=HEADING1-66></A>
<H3>A.5.1   Creating a softwidget</H3>
 To create a softwidget, mark the widget you want to convert to a softwidget and select File/Save as softwidget. <P>
  <img SRC="user_save_as_softwidget.gif" border=0></a><P>
FIGURE 4.  The Save as softwidget dialoge<P>
 The module is the module that contains the logic for the GUI. The filename of the resource file will be module + ".swr". The exports field is a list of exported options. Options can be either a GS option or a user defined option. A GS option is an option that controlls the GUI, a user defined option is a option that is passed to the logic of the softwidget. GS options have the syntax<P>
<PRE>
{{Name, Type},Default}
</PRE>
 Where <CODE>Name</CODE> is the name of a widget, <CODE>Type</CODE> is the option to be controlled and <CODE>Default</CODE> is the value the option will have when a softwidget is controlled. User defined options have the syntax<P>
<PRE>
{Name, Default}
</PRE>
 Where <CODE>Name</CODE> is an input parameter for the module with <CODE>Default</CODE> as default value. Only exported options will be editable from the option window.<P>
 Example of a GS option is <CODE>{{label, text}, "File dialog"}.</CODE> The user of the softwidget will then be able to change the text of label from GSB. An example of a user define option is <CODE>{state, load},</CODE> where the user can control the state of the loop for a file dialog. <CODE>State</CODE> could for example have to different possible values, <CODE>load</CODE> and <CODE>save</CODE>. <P>
 <P>
<A NAME=HEADING1-77></A>
<H3>A.5.2   Writing the module</H3>
 When a softwidget is included in a GUI and the GUI is started, module:start/2 will be invoked (module is the module that controls the logic for the softwidget). The module is then responsible for the creation of the softwidget GUI. <P>
<PRE>

-module(gen_file_dialog).
-export([start/2, init/2, request/0, stop/0]).

start(GS, Opts) -&gt;
  Pid = spawn(gen_file_dialog, init, [GS, Opts]),
  register(gen_file_dialog, Pid).

init(GS,Opts) -&gt;
  case gsb_run:start_sw(GS, gen_file_dialog, Opts) of
    {ok, UserOpts} -&gt;
      true;
    {error, Reason} -&gt;
      io:format("gen_file_dialog error: ~p~n", 
			                [Reason]),
      exit(error)
  end,
  {ok, Dir} = file:get_cwd(),
  Mode = gsb_run:get_value(mode, UserOpts),
  File = gsb_run:get_value(file, UserOpts),
  gs:config(entry, {text, File}),
  gs:config(gen_file_dialog, {map, false}),
  refresh(Dir),
  request_loop(Dir, GS, State).
</PRE>
Example 3.   A softwidget module<P>
<A NAME=HEADING1-104></A>
<H2>A.6   gsb_run module</H2>
<HR>
 The gsb_run module is used from Erlang programs that control the logic of GUI's. Following is a list of available functions and a short description.<P>
<UL>
<LI><CODE>start(GS, Module)</CODE>, searches for a module to start. If there is module namned Module + "_ui" compiled, this will be started, otherwise the resource file Module + ".rc" will be started.<P>
<LI><CODE>start_sw(GS, Module, Opts)</CODE>, starts GUI in the softwidgets resource file, from the softwidget process (This is important, otherwise name conflict may occur) with GS as the parent of the top widget. Returns <CODE>{ok, UserOpts} </CODE>or <CODE>{error, Reason}</CODE> where <CODE>UserOpts</CODE> are the values that are to be extracted by <CODE>get_value/2.</CODE><P>
<LI><CODE>get_value(Type, Opts)</CODE>, returns the value of option <CODE>Type</CODE> in the list <CODE>Opts</CODE>.<P>
<LI><CODE>rc2erl(Module)</CODE>, converts a resource file to an Erlang program, which can be compiled to a separate module. The result will be a file namned <CODE>Module</CODE> + "_ui.erl". <P>
</UL>
<A NAME=HEADING1-110></A>
<H2>A.7   Known problems</H2>
<HR>
<UL>
<LI>This is the first Beta (Alfa?) unsupported release of GSB, please be patient and report all bugs to <B>support@erlang.ericsson.se</B><P>
<LI>GSB is sensitive regarding files and paths. If a file is missing, GSB sometimes crashes due to minimalistic error check.<P>
<LI>It is not possible to place more than one widget at a time in the draw area. If you want to place several buttons, you will have to select button in the toolbox each time.<P>
<LI>The parser in the option window is not complete, sometimes wrong values are passed further in the system.<P>
<LI>The hierarchy sometimes displays a widget name without a '-' sign. This is only a cosmetic error, it fixes it self if doubleclicking on it.  <P>
<LI>The "Don't snap" alternative in draw do not propagate information properly. To disabel a widget from the grid, mark and unmark after selecting "Don't snap" in the popup-menu.<P>
<LI>Softwidgets can only export userdefined options or propertys, no events!<P>
<LI>Interfaces and everything may be changed without notice.<P>
</UL>
 <P>
 <P>
 <P>
<A NAME=HEADING1-122></A>
<H2>Appendix  B -  Tutorial</H2>
<HR>
<A NAME=HEADING1-123></A>
<H2>B.1   A simple GUI</H2>
<HR>
 Start GSB with<P>
 gsb:start().<P>
 Choose File/New Window<P>
 Select widgets in toolbox, place on draw area<P>
 Set correct options<P>
 Save resource file<P>
 <P>
<A NAME=HEADING1-131></A>
<H2>B.2   A softwidget</H2>
<HR>
 1. Create the widgets you want to group into a softwidget, preferable in a frame.<P>
 2. Mark the bottom widget.<P>
 3. File/Save as softwidget<P>
 4. Module is the name of the module that will be called when the application starts<P>
  Exports is a list of tuples, either gs options or user defined. The syntax for the gs options are:<P>
 {{name, option}, value}<P>
 {option, value}<P>
 5. The resource file will be saved in "module_ui.rc"<P>
 6. Import the created softwidget into the toolbox<P>
<A NAME=HEADING1-141></A>


<!-- FM pgf ignored -->
</BODY>
</HTML> 
