<!doctype erlref PUBLIC "-//Stork//DTD erlref//EN">
<!-- 
 ``The contents of this file are subject to the Erlang Public License,
 Version 1.1, (the "License"); you may not use this file except in
 compliance with the License. You should have received a copy of the
 Erlang Public License along with this software. If not, it can be
 retrieved via the world wide web at http://www.erlang.org/.
 
 Software distributed under the License is distributed on an "AS IS"
 basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 the License for the specific language governing rights and limitations
 under the License.
 
 The Initial Developer of the Original Code is Ericsson Utvecklings AB.
 Portions created by Ericsson are Copyright 1999, Ericsson Utvecklings
 AB. All Rights Reserved.''
 
     $Id$
-->
<erlref>
  <header>
    <title>dialyzer</title>
    <prepared></prepared>
    <docno></docno>
    <date></date>
    <rev></rev>
  </header>
  <module>dialyzer</module>
  <modulesummary>The Dialyzer, a DIscrepancy AnalYZer for ERlang
    programs</modulesummary>
  <description>
    <p>The Dialyzer is a static analysis tool that identifies software discrepancies
      such as type errors, unreachable code, unnecessary tests, etc in single Erlang
      modules or entire (sets of) applications. Currently, Dialyzer starts its
      analysis for either BEAM bytecode or from Erlang source code and reports
      to its user the functions where the discrepancies occur and an indication
      of what the discrepancy is about. Dialyzer currently supports various modes
      of operation and its analysis is precise (in particular, there are no false
      positives) and quite fast.</p>

    <p>Read more about Dialyzer and about how to use it from the GUI in
      <seealso marker="dialyzer_chapter">Dialyzer User's Guide</seealso>.
    </p>
  </description>

  <section>
    <title>Using the Dialyzer from the command line</title>

    <p>Dialyzer also has a command line version for automated use. Below is a
      brief description of the list of its options. The same information can
      be obtained by writing</p>
    <code>
      dialyzer --help
    </code>
    <p>in a shell. Please refer to the GUI description for more details on
      the operation of Dialyzer.</p>

    <p>The exit status of the command line version is:</p>
    <code>
      0 - No problems were encountered during the analysis and no
          warnings were emitted.
      1 - Problems were encountered during the analysis.
      2 - No problems were encountered, but warnings were emitted.
    </code>

    <p>Usage:</p>
    <code>
      dialyzer [--otp OTP_DIR] [--help] [--version] [--shell]
               [-pa dir]* [-plt plt] [-Ddefine]* [-I include_dir]* 
               [--output_plt file] [-Wwarn]*  [--src] 
               [-c applications] [-r applications] [-o outfile] [-q]
    </code>

    <p>Options:</p>
    <taglist>
      <tag><c>-c applications</c> (or <c>--command-line applications</c>)
      </tag>
      <item>
	use Dialyzer from the command line (no GUI) to detect defects in the
	specified applications (directories or <c>.erl</c> or <c>.beam</c> files)
      </item>
      <tag><c>-r applications</c></tag>
      <item>
	same as <c>-c</c> only that directories are searched recursively for 
	subdirectories containing <c>.erl</c> or <c>.beam</c> files (depending on the 
	type of analysis)
      </item>
      <tag><c>-o outfile</c> (or <c>--output outfile</c>)</tag>
      <item>
	when using Dialyzer from the command line, send the analysis
	results in the specified <c>outfile</c> rather than in stdout
      </item>
      <tag><c>--src</c></tag>
      <item>
	overwrite the default, which is to analyze BEAM bytecode, and
	analyze starting from Erlang source code instead
      </item>
      <tag><c>-Dname</c> (or <c>-Dname=value</c>)</tag>
      <item>
	when analyzing from source, pass the define to Dialyzer (**)
      </item>
      <tag><c>-I include_dir</c></tag>
      <item>
	when analyzing from source, pass the <c>include_dir</c> to Dialyzer (**)
      </item>
      <tag><c>--output_plt file</c></tag>
      <item>
	Store the plt at the specified location after building it.
      </item>
      <tag><c>--no_warn_on_inline</c></tag>
      <item>
	Suppress warnings when analyzing an inline compiled bytecode file.
      </item>
      <tag><c>-plt plt</c></tag>
      <item>
	Use the specified plt as the initial plt. If the plt was built 
	during setup the files will be checked for consistency.
      </item>
      <tag><c>-pa dir</c></tag>
      <item>
	Include <c>dir</c> in the path for Erlang. Useful when analyzing files
	that have <c>-include_lib()</c> directives.
      </item>
      <tag><c>-Wwarn</c></tag>
      <item>
	a family of option which selectively turn on/off warnings.
	(for help on the names of warnings use <c>dialyzer -Whelp</c>)
      </item>
      <tag><c>--check_init_plt</c></tag>
      <item>
	Only checks if the init plt is up to date. For installed systems
	this also forces the rebuilding of the plt if this is not the case.
      </item>
      <tag><c>--otp OTP_DIR</c></tag>
      <item>
	overrides the default location of the Erlang/OTP system to use
      </item>
      <tag><c>--shell</c></tag>
      <item>
	do not disable the Erlang shell while running the GUI
      </item>
      <tag><c>--version (or -v)</c></tag>
      <item>
	prints the Dialyzer version and some more information and exits
      </item>
      <tag><c>--help (or -h)</c></tag>
      <item>
	prints this message and exits
      </item>
      <tag><c>-q</c></tag>
      <item>
	makes Dialyzer a bit more quiet
      </item>
      <tag><c>--verbose</c>
      <item>
       makes Dialyzer a bit more verbose
      </item>
    </taglist>

    <note>
      <p>* denotes that multiple occurrences of these options are possible.</p>
      <p>** options <c>-D</c> and <c>-I</c> work both from command-line and in the Dialyzer GUI;
	the syntax of defines and includes is the same as that used by <c>erlc</c>.</p>
    </note>

    <p>Warning options:</p>
    <taglist>
      <tag><c>-Wno_return</c></tag>
      <item>
	Suppress warnings for functions of no return.
      </item>
      <tag><c>-Wno_unused</c></tag>
      <item>
	Suppress warnings for unused functions.
      </item>
      <tag><c>-Wno_improper_lists</c></tag>
      <item>
	Suppress warnings for construction of improper lists.
      </item>
      <tag><c>-Wno_tuple_as_fun</c></tag>
      <item>
	Suppress warnings for using tuples instead of funs.
      </item>
      <tag><c>-Wno_fun_app</c></tag>
      <item>
	Suppress warnings for fun applications that will fail.
      </item>
      <tag><c>-Wno_match</c></tag>
      <item>
	Suppress warnings for pattern matching operations that will never
	succeed.
      </item>
      <tag><c>-Wno_comp</c></tag>
      <item>
	Suppress warnings for term comparisons that will always return <c>false</c>.
      </item>
      <tag><c>-Wno_guards</c></tag>
      <item>
	Suppress warnings for guards that will always fail.
      </item>
      <tag><c>-Wno_unsafe_beam</c></tag>
      <item>
	Suppress warnings for unsafe BEAM code produced by an old
	BEAM compiler.
      </item>
      <tag><c>-Werror_handling</c> ***</tag>
      <item>
	Include warnings for functions that only return by means of an
	exception.
      </item>
    </taglist>

    <note>
      <p>*** This is the only option that turns on warnings rather than 
	turning them off.</p>
    </note>
  </section>

  <section>
    <title>Using the Dialyzer from Erlang</title>
    <p>You can also use Dialyzer directly from Erlang. Both the gui and the
      command line version is available. The options are similar to the ones
      given from the command line, so please refer to the sections above for
      a description of these.
  </section>

  <funcs>
    <func>
      <name>gui() -> ok | {error, Msg}</name>
      <name>gui(OptList) -> ok | {error, Msg}</name>
      <fsummary>Dialyzer GUI version</fsummary>
      <type>
	<v>OptList -- see below</v>
      </type>
      <desc>
	<p>Dialyzer GUI version.</p>

	<code>
OptList  : [Option]
Option   : {files,          [Filename : string()]}
	 | {files_rec,      [DirName : string()]}
	 | {defines,        [{Macro: atom(), Value : term()}]}
	 | {from,           src_code | byte_code} %% Defaults to byte_code
	 | {init_plt,       FileName : string()}  %% If changed from default
	 | {include_dirs,   [DirName : string()]} 
	 | {output_file,    FileName : string()}
	 | {supress_inline, bool()}               %% Defaults to true
	 | {warnings,       [WarnOpts]}

WarnOpts : no_return
	 | no_unused
	 | no_improper_lists
	 | no_tuple_as_fun
	 | no_fun_app
	 | no_match
	 | no_comp
	 | no_guards
	 | no_unsafe_beam
	 | no_fail_call
	 | error_handling
	</code>
      </desc>
    </func>

    <func>
      <name>run(OptList) -> {ok, Warnings, Errors} | {ok, Warnings}
	| {error, Message}</name>
      <fsummary>Dialyzer command line version</fsummary>
      <type>
	<v>OptList -- see gui/0,1</v>
	<v>Warnings = [{MFA, string()}]</v>
	<v>&nbsp;MFA = {Module, Function, Arity}</v>
	<v>&nbsp;&nbsp;Module = Function = atom()</v>
	<v>&nbsp;&nbsp;Arity = int()</v>
	<v>Errors = string()</v>
	<v>Message = string()</v>
      </type>
      <desc>
	<p>Dialyzer command line version.</p>
      </desc>
    </func>
  </funcs>

  <authors>
    <aname>Tobias Lindahl</aname>
    <email>tobias.lindahl@it.uu.se</email>
    <aname>Kostis Sagonas</aname>
    <email>kostis@it.uu.se</email>
  </authors>
</erlref>
