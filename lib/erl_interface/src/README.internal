******************************************************************************
                                 General
******************************************************************************

There are two different interfaces, the old 'erl_interface' and 'ei'.
The old interface is to depend on the new one, not the other way arount.

Erl_interface should be "thread safe", i.e. you should be able to 
handle connections, convert data etc from different threads.

Ei should be "reentrant" or "async safe", i.e. no locks should be set
so that if an ei function is called inside an signal handler there
could be a deadlock.

VxWorks call the operating processes "tasks". These are to be handled the
same way as Unix threads, i.e. there can only be one C node for all tasks
using the old interface.


******************************************************************************
                               Directories
******************************************************************************

 * src/aux/

   Support files for configure described in the next section

 * src/legacy/

   Old erl_interface stuff  FIXME what about thread support etc....?

 * src/connect/

   Create nodes, connections, communication with the other node etc

 * src/decode/

   Simple decode functions

 * src/encode/

   Simple encode functions

 * src/epmd/

   Handle communication with epmd

 * src/registry/

   Key/value database with optional mnesia back up

 * src/misc/

   The rest of the library

 * src/prog/

   erl_call and some test programs for compiling and linking

 * src/not_used/

   Strange, some files are not used....


******************************************************************************
                      Configuration support files
******************************************************************************

The build uses GNU configure and libtool. The libtool and autoconf
package don't need to be installed to configure and build the
sources. But in "maintainer mode" you need them to update some files
in the source distribution.

 * configure.in 

   Used in maintainer mode together with "aclocal.m4" to create
   "configure". "configure.in" is hand written and only need to
   be updated when you change the sources to use new header files
   or C compiler features. You may get some hints about what to
   update using a recent autoconf package and do

     % cd erl_inteface
     % autoscan src

   The result to compare with the current "configure.in" will be
   stored in "src/configure.scan".

 * aclocal.m4

   This file contains macros generated by ??? appended
   with the content of "libtool.m4" in the installed libtool
   package. (FIXME don't know when this is to be updated and
   why it contains so much).

 * src/aux/config.guess
 * src/aux/config.sub

   Used by "configure" to form the subdirectory name
   "cpu-vendor-os".

 * src/aux/install-sh*

   Used if no other BSD compatible install script is found.

 * src/aux/config.h.in

   Used by "configure" as a template for the resulting
   "src/config.h". The file "config.h.in" should be
   updated when "configure.in" is updated because the
   new macros used in your source and this is the file
   where they are listed. You can find out what to update
   using

     % autoheader

 * ltmain.sh

   This is XXX (FIXME what?)

The base for the configure.in script was created with 'autoscan'.
The base for the config.h.in file was created with 'autoheader'.


******************************************************************************
                          Writing source
******************************************************************************

All header files should include "eidef.h". It contains some common
constants and macros and includes config.h.

In general avoid including other header files from header files.
The exception is to make the protoypes complete to the user of
this library, i.e. to include <stdio.h> to defined FILE or
to include "ei_x_encode" to define the type ei_x_buff.

The function ei_decode_term() (FIXME encode_term?) work on ETERM,
i.e. it converts between the old erl_interface format and ei.
Because of this it is really part of the erl_interface library,
not the ei library.

Use uint8, uint16, uint32, int8, int16, and int32 for types
where size matters ;-) Use uint8 for buffers where we construct
messages.


******************************************************************************
                          Global variables
******************************************************************************

There are two reasons we avoid global variables:

  - It is much easier to support threads without them

  - On operating systems like VxWorks the global variable is global
    to all operating system processes.

There are a few global variables that are ok

  ei_x_extra	         This is set to 100 in "ei_x_encode.c" but can be
                         changed for debugging the memory allocation.

  ei_trace_distribution  Enable verbose tracing on stderr.

  errno			 In the non threaded version of the lib this
			 is a global variable.

  __erl_errno 		 This is a global handled by "ei_pthreads.c"

You can check for globals using something like

  % nm -g ei_fake_prog | fgrep OBJT

Global variables but with local scope

  erl_if_ec              Global state, is ok


********************************* EOF ****************************************
