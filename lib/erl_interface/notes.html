<html>
<head>
  <title>Erl_Interface Release Notes</title>
  <style type="text/css">
<!--
    body          { background: white; margin: 3em }

    body          { font-family: Verdana, Arial, Helvetica, sans-serif }
    h1 h2 h3 h4   { font-family: Verdana, Arial, Helvetica, sans-serif }
    h1            { font-size: 48 }
    p li          { font-family: Verdana, Arial, Helvetica, sans-serif }
-->
  </style>
</head>

<body bgcolor=white>

<center><h1>ErlInterface Release Notes</h1></center>


<!--- ################################################################# --->

<h2>Erl_interface 3.4</h2>


<!--- ----------------------------------------------------------------- --->

<h3>Fixed errors and malfunctions</h3>

<ul>

  <li>
    erl_print_term() and erl_copy_term() couldn't previously handle uints.
    This bug has now been fixed.<br>
    (Own Id: OTP-4061)<br>
    (Aux Id: seq7079)<p>
  </li>

  <li>
    ei_x_format() was not working correctly for floating point arguments on
    some platforms. This is now corrected.<br>
    (Own Id: OTP-4379)<p>
  </li>

  <li>
    erl_compare_ext() didn't compare the node parts of pids, ports, and
    references. This has now been fixed. Comparison between two
    <code>pid</code>s, <code>port</code>s, or <code>reference</code>s does
    now conform to the Erlang specification.<br>
    (Own Id: OTP-4512)<br>
    (Aux Id: OTP-4511)<p>
  </li>

</ul>


<!--- ----------------------------------------------------------------- --->

<h3>Improvements and new features</h3>

<ul>

  <li>
    Erl_interface and EI now supports 64 bit architectures.
    (Own Id: OTP-4772)
  </li>
  <li>
    There are new functions that support the GCC and Visual C++ 64 bit
    extended integer types
    <p>
    &nbsp;&nbsp;int ei_decode_longlong(const char *buf, int *index, EI_LONGLONG *p);
    <br>
    &nbsp;&nbsp;int ei_decode_ulonglong(const char *buf, int *index, EI_ULONGLONG *p);
    <br>
    &nbsp;&nbsp;int ei_encode_longlong(char *buf, int *index, EI_LONGLONG p);
    <br>
    &nbsp;&nbsp;int ei_encode_ulonglong(char *buf, int *index, EI_ULONGLONG p);
    <br>
    &nbsp;&nbsp;int ei_x_encode_longlong(ei_x_buff* x, EI_LONGLONG n);
    <br>
    &nbsp;&nbsp;int ei_x_encode_ulonglong(ei_x_buff* x, EI_ULONGLONG n);
    (Own Id: OTP-4772)
  </li>
  <li>
    If you compile the library from source you can use the ei library
    together with GMP, the GNU multi precision library, to convert
    integers larger than 64 bits from and to the external format.
    <p>
    &nbsp;&nbsp;int ei_decode_bignum(const char *buf, int *index, mpz_t obj);
    <br>
    &nbsp;&nbsp;int ei_encode_bignum(char *buf, int *index, mpz_t obj);
    <br>
    &nbsp;&nbsp;int ei_x_encode_bignum(ei_x_buff *x, mpz_t obj);
    (Own Id: OTP-4772)
  </li>
  <li>
    Some general code improvements where done like correcting
    buffer sizes, added more error checking etc.<br>
    (Own Id: OTP-4772)
  </li>
  <li>
    In order to conform to the Erlang specification, comparison between two
    pids was changed in the R9B release. This change did however break a
    deadlock- prevention algorithm used by mnesia during release upgrade.
    Therefore, comparison between two pids has been changed back so that
    R9B nodes are compatible with Erlang nodes running pre-R9 releases.
    <br> Pre-R9 comparison between two pids which now is used again: If t1
    and t2 are both pids, t1 will precede t2 if and only if either * the
    node local id of t1 precedes the node local id of t2, or * the node
    local ids of t1 and t2 are equal, and node(t1) precedes node(t2), or *
    the node local ids of t1 and t2 are equal, and also node(t1) and
    node(t2) are equal, and node(t1) was created before node(t2). <br> The
    node local id consist of two integers; serial which is most
    significant, and number. <br> The Erlang specification states: If t1
    and t2 are both refs, both PIDs, or both ports, then t1 precedes t2 if
    and only if either * node(t1) precedes node(t2), or * node(t1) equals
    node(t2) and t1 was created before t2. <br> Note that comparisons
    between two refs, or two ports will still conform to the Erlang
    specification.<br>
    (*** POTENTIAL INCOMPATIBILITY ***)<br>
    (Own Id: OTP-4715)<br>
    (Aux Id: OTP-4511, OTP-4512)<p>
  </li>

</ul>


<!--- ################################################################# --->

<h2>ErlInterface 3.3</h2>


<!--- ----------------------------------------------------------------- --->

<h3>Improvements and new features</h3>

<ul>

  <li>
     ErlInterface has been rewritten extensively. The library <code>ei
     </code> is now documented and supported. The old
     <code>erl_interface</code> is considered obsolete, and provided
     only for backward compatibility.
  </li>

  <li>
    ErlInterface is now thread-safe, and multiple C-nodes may run from
    the same process.
  </li>

  <li>
    New functions are added for connecting and accepting connections
    from <code>ei</code>; these are documented in <code>ei_connect
    </code>.
  </li>

  <li>
     New functions are added for converting to and from erlang binary
     format; these are documented in <code>ei</code>.
  </li>

</ul>



There are also release notes for
<a href="notes_history.html">older versions</a>.

</body>
</html>
