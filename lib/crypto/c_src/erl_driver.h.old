/*
 * This file is copyright (c) Ellemtel in December 1992, 
 * Ericsson Telecom AB 1998.
 *
 * Include file for erlang driver writers 
 *
 * New version by Peter Hogfeldt.
 */

#ifndef __ERL_DRIVER_H__
#define __ERL_DRIVER_H__

#include "driver_int.h"

#undef _ANSI_ARGS_
#undef CONST

#if ((defined(__STDC__) || defined(SABER)) && !defined(NO_PROTOTYPE)) || defined(__cplusplus) || defined(USE_PROTOTYPE)
#   define _USING_PROTOTYPES_ 1
#   define _ANSI_ARGS_(x)	x
#   define CONST const
#else
#   define _ANSI_ARGS_(x)	()
#   define CONST
#endif

#ifdef __cplusplus
#   define EXTERN extern "C"
#else
#   define EXTERN extern
#endif

/* Values for mode arg to driver_select() */

#define DO_READ	 (1 << 0)
#define DO_WRITE (1 << 1)

#define PORT_CONTROL_FLAG_BINARY	1

/* This macro is used to name a dynamic driver's init function in
 * a way that doesn't lead to conflicts. This is crucial when using
 * operating systems that has one namespace for all symbols
 * (e.g. VxWorks). Example: if you have an dynamic driver C source
 * file named echo_drv.c, you use the macro like this:
 * 
 *    DriverEntry *DRIVER_INIT(echo_drv)(void *handle) 
 */

#if defined(VXWORKS)
#    define DRIVER_INIT(DRIVER_NAME) DRIVER_NAME  ## _init
#elif defined(__WIN32__)
#    define DRIVER_INIT(DRIVER_NAME) __declspec(dllexport) driver_init
#else 
#    define DRIVER_INIT(DRIVER_NAME)  driver_init
#endif

extern int null_func();

/* This structure MUST match Binary in global.h exactly!!! */
typedef struct driver_binary {
    int orig_size;        /* total length of binary */
    int refc;             /* number of references to this binary */
    char orig_bytes[1];   /* the data (char instead of byte!) */
} DriverBinary;


/* 
 * This structure contains options to all built in drivers.
 * None of the drivers use all of the fields.
 * XXX This structure must match SysDriverOpts in sys.h. In fact, the
 * proper place is this file, and not sys.h.
 * 
 */
 
typedef struct _SysDriverOpts {
    int ifd;                    /* Input file descriptor (fd driver only). */
    int ofd;                    /* Outputfile descriptor (fd driver only). */
    int packet_bytes;           /* Number of bytes in packet header. */
    int read_write;             /* DO_READ and DO_WRITE bits. */
    int use_stdio;              /* Use standard I/O: TRUE or FALSE. */
    int redir_stderr;           /* Redirect stderr to stdout: TRUE or FALSE. */
    int hide_window;            /* Hide this windows (Windows only). */
    char *envir;                /* Environment of the port process
				   in Windows format (Windows only) */
    char *wd;                   /* Working directory. */
} SysDriverOpts;


typedef struct {
    int vsize;			/* length of vectors */
    int size;			/* total size in bytes */
    SysIOVec* iov;
    DriverBinary** binv;
} ErlIOVec;

typedef long PortRef;		/* XXX ?? */

typedef struct driver_entry {
    int (*init)(void);		/* called at system start up for statically
				   linked drivers, and after loading for
				   dynamically loaded drivers */ 
    PortRef (*start)(int port_num, char *command, SysDriverOpts *opts);
				/* called when open_port/2 is invoked.
				   return value -1 means failure. */
    int (*stop)(PortRef port_ref); /* called when port is closed, and when the
				   emulator is halted. */
    int (*output)(PortRef port_ref, char *buf, int len);
				/* called when we have output from erlang to 
				   the port */
    int (*ready_input)(PortRef port_ref, int handle); 
				/* called when we have input from one of 
				   the driver's handles) */
    int (*ready_output)(PortRef port_ref, int handle);  
				/* called when output is possible to one of 
				   the driver's handles */
    char *driver_name;		/* name supplied as command 
				   in open_port XXX ? */
    int (*finish)(void);        /* called before unloading the driver -
				   DYNAMIC DRIVERS ONLY */
    void *handle;		/* file handle - DYNAMIC DRIVERS ONLY */
    int (*control)(PortRef port_ref, unsigned int command, char *buf, 
		   int len, char **rbuf, int rlen); 
				/* "ioctl" for drivers - invoked by 
				   port_command/3) */
    int (*timeout)(PortRef port_ref);	/* Handling of timeout in driver */
    int (*outputv)(PortRef port_ref, ErlIOVec *ev);  
				/* called when we have output from erlang
				   to the port */
} DriverEntry;

/* For dynamically loaded drivers, the init function in DriverEntry is 
 * not used. Instead the driver must contain a function 
 *  
 *     DriverEntry *driver_init(void *handle)
 *
 * which is called by the system when the driver is loaded. It must
 * initialize a DriverEntry structure and return a pointer to it. In
 * particular the 'handle' member of the structure must be set to 
 * 'handle' value obtained as argument of the call.
 *
 */

typedef struct de_list {
    DriverEntry *drv;
    struct de_list *next;
} DE_List;

extern DE_List *driver_list;

/* These are the kernel functions available for driver writers */

EXTERN int driver_select(int port_num, int handle, int mode, int on);
EXTERN int driver_output(int port_num, char *buf, int len);
EXTERN int driver_output2(int port_num, char *hbuf, int hlen, 
			  char *buf, int len);
EXTERN int driver_output_binary(int port_num, char *hbuf, int hlen,
				DriverBinary* bin, int offset, int len);
EXTERN int driver_outputv(int port_num, char* hbuf, int hlen, ErlIOVec *ev,
			  int skip);
EXTERN int driver_vec_to_buf(ErlIOVec *ev, char *buf, int len);
EXTERN int driver_set_timer(int port_num, unsigned long time);
EXTERN int driver_cancel_timer(int port_num);

/*
 * The following functions are used to initiate a close of a port
 * from a driver.
 */
EXTERN int driver_failure_eof(int port_num);
EXTERN int driver_failure_atom(int port_num, char *string);
EXTERN int driver_failure_posix(int port_num, int error);
EXTERN int driver_failure(int port_num, int error);


EXTERN char* erl_errno_id(int error);
EXTERN void set_busy_port(int port_num, int on);
EXTERN void add_driver_entry(DriverEntry *de);
EXTERN int remove_driver_entry(DriverEntry *de);
EXTERN void set_port_control_flags(int port_num, int flags);

/* Binary interface */
/* NOTE: DO NOT overwrite a binary with new data (if the data is delivered);
** since the binary is a shared object it MUST be written once.
*/

EXTERN DriverBinary* driver_alloc_binary(int size);
EXTERN DriverBinary* driver_realloc_binary(DriverBinary *bin, int size);
EXTERN void driver_free_binary(DriverBinary *bin);

/* Allocation interface */
EXTERN void *driver_alloc(size_t size);
EXTERN void *driver_realloc(void *ptr, size_t size);
EXTERN void driver_free(void *ptr);

/* Queue interface */
EXTERN int driver_enq(int port_num, char* buf, int len);
EXTERN int driver_pushq(int port_num, char* buf, int len);
EXTERN int driver_deq(int port_num, int size);
EXTERN int driver_sizeq(int port_num);
EXTERN int driver_enq_bin(int port_num, DriverBinary *bin, int offset, 
			  int len);
EXTERN int driver_pushq_bin(int port_num, DriverBinary *bin, int offset,
			    int len);

EXTERN SysIOVec* driver_peekq(int port_num, int *vlen);
EXTERN int driver_enqv(int port_num, ErlIOVec *ev, int skip);
EXTERN int driver_pushqv(int port_num, ErlIOVec *ev, int skip);

/* shared libs & dlls */
EXTERN void *driver_dl_open(char *);
EXTERN void *driver_dl_sym(void *, char *);
EXTERN int driver_dl_close(void *);
EXTERN char *driver_dl_error(void);


#endif
