<!DOCTYPE CHAPTER PUBLIC "Stork//DTD chapter//EN">
<!-- 
 ``The contents of this file are subject to the Erlang Public License,
 Version 1.1, (the "License"); you may not use this file except in
 compliance with the License. You should have received a copy of the
 Erlang Public License along with this software. If not, it can be
 retrieved via the world wide web at http://www.erlang.org/.
 
 Software distributed under the License is distributed on an "AS IS"
 basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 the License for the specific language governing rights and limitations
 under the License.
 
 The Initial Developer of the Original Code is Ericsson Utvecklings AB.
 Portions created by Ericsson are Copyright 1999, Ericsson Utvecklings
 AB. All Rights Reserved.''
 
     $Id$
-->
<CHAPTER>
  <HEADER>
    <TITLE>The Jinterface Package</TITLE> 
    <PREPARED>Gordon Beaton, Babbis Xagorarakis
    <RESPONSIBLE>Gordon Beaton, Babbis Xagorarakis
    <DOCNO>
    <APPROVED>
    <CHECKED>
    <DATE>000822
    <REV>A
    <FILE>jinterface.sgml
  </HEADER>

<P>The <seealso marker="java/com/ericsson/otp/erlang/package-summary">Jinterface</> package provides 
a set of tools for communication with Erlang processes. It can also be used for communication with 
other Java processes using the same package, as well as C processes using the Erl_Interface library.  

<P>The set of classes in the package can be divided into two categories:
those that provide the actual communication, and those that provide a
Java representation of the Erlang data types. The latter are all
subclasses of OtpErlangObject, and they are identified by the
OtpErlang prefix.

<P>Since this package provides a mechanism for communicating with Erlang,
message recipients can be Erlang processes or instances of
com.ericsson.otp.erlang.OtpMbox, both of which are identified with
pids and possibly registered names. When pids or mailboxes are
mentioned as message senders or recipients in this section, it should
assumed that even Erlang processes are included, unless specified
otherwise.

The classes in
<seealso marker="java/com/ericsson/otp/erlang/package-summary">Jinterface</> support the following:
<LIST>

<ITEM>manipulation of data represented as Erlang data types
<ITEM>conversion of data between Java and Erlang formats
<ITEM>encoding and decoding of Erlang data types for transmission or storage
<ITEM>communication between Java nodes and Erlang processes
</LIST>

<P>In the following sections, these topics are described:

<LIST>

<ITEM>mapping of Erlang types to Java
<ITEM>encoding, decoding, and sending Erlang terms
<ITEM>connecting to a distributed Erlang node
<ITEM>using nodes, mailboxes and EPMD
<ITEM>sending and receiving Erlang messages and data
<ITEM>remote procedure calls
<ITEM>linking to remote processes
<ITEM>compiling your code for use with Jinterface
<ITEM>tracing message flow
</LIST>


<SECTION><TITLE>Mapping of Basic Erlang Types to Java</TITLE>
<p>
This section describes the mapping of Erlang basic types to Java. 
</p>

<table>
<row><cell>Erlang type</cell><cell>Java type</cell></row>

<row><cell>atom</cell>
	    <cell>
	      <seealso marker="java/com/ericsson/otp/erlang/OtpErlangAtom">OtpErlangAtom</></cell></row>

<row><cell>binary</cell>
	    <cell>
	      <seealso marker="java/com/ericsson/otp/erlang/OtpErlangBinary">OtpErlangBinary</></cell></row>

<row><cell>floating point types</cell>
	    <cell>
	      <seealso marker="java/com/ericsson/otp/erlang/OtpErlangFloat">OtpErlangFloat</> or 
	      <seealso marker="java/com/ericsson/otp/erlang/OtpErlangDouble">OtpErlangDouble</>,
	      depending on the floating point value size</cell></row>

<row><cell>integral types</cell>
     <cell>One of 
	   <seealso marker="java/com/ericsson/otp/erlang/OtpErlangByte">OtpErlangByte</>,
	   <seealso marker="java/com/ericsson/otp/erlang/OtpErlangChar">OtpErlangChar</>,
	   <seealso marker="java/com/ericsson/otp/erlang/OtpErlangShort">OtpErlangShort</>,
	   <seealso marker="java/com/ericsson/otp/erlang/OtpErlangUShort">OtpErlangUShort</>,
           <seealso marker="java/com/ericsson/otp/erlang/OtpErlangInt">OtpErlangInt</>,
           <seealso marker="java/com/ericsson/otp/erlang/OtpErlangUInt">OtpErlangUInt</> or
           <seealso marker="java/com/ericsson/otp/erlang/OtpErlangLong">OtpErlangLong</>,
	   depending on the integral value size and sign</cell></row>

<row><cell>list</cell>
	    <cell>
	      <seealso marker="java/com/ericsson/otp/erlang/OtpErlangList">OtpErlangList</></cell></row>

<row><cell>pid</cell>
	    <cell>
	      <seealso marker="java/com/ericsson/otp/erlang/OtpErlangPid">OtpErlangPid</></cell></row>

<row><cell>port</cell>
	    <cell>
	      <seealso marker="java/com/ericsson/otp/erlang/OtpErlangPort">OtpErlangPort</></cell></row>

<row><cell>ref</cell>
	    <cell>
	      <seealso marker="java/com/ericsson/otp/erlang/OtpErlangRef">OtpErlangRef</></cell></row>

<row><cell>tuple</cell>
	    <cell>
	     <seealso marker="java/com/ericsson/otp/erlang/OtpErlangTuple">OtpErlangTuple</></cell></row>

<row><cell>term</cell>
	    <cell>
	      <seealso marker="java/com/ericsson/otp/erlang/OtpErlangObject">OtpErlangObject</></cell></row>

<tcaption>Mapping of Erlang basic types to Java</tcaption>
</table>
</SECTION>

<SECTION><TITLE>Special Mapping Issues</TITLE>

<p>The atoms <c>true</> and <c>false</> are special atoms, used as boolean values. 
The class <seealso marker="java/com/ericsson/otp/erlang/OtpErlangBoolean">OtpErlangBoolean</> can be used to represent these.

<p>Lists in Erlang are also used to describe sequences of printable characters (strings).
A convenience class <seealso marker="java/com/ericsson/otp/erlang/OtpErlangString">OtpErlangString</>
is provided to represent Erlang strings.

</SECTION>


<SECTION><TITLE>Nodes</TITLE>

<P>A node as defined by Erlang/OTP is an instance of the Erlang Runtime
System, a virtual machine roughly equivalent to a JVM. Each node has a
unique name in the form of an identifier composed partly of the
hostname on which the node is running, e.g "gurka@sallad.com". Several
such nodes can run on the same host as long as their names are unique.

The class <seealso marker="java/com/ericsson/otp/erlang/OtpNode">OtpNode</> 
represents an Erlang node. It is created with a name
and optionally a port number on which it listens for incoming
connections. Before creating an instance of 
<seealso marker="java/com/ericsson/otp/erlang/OtpNode">OtpNode</>, 
ensure that Epmd is running on the host machine. See the Erlang documentation 
for more information about Epmd. In this example, the host name is appended
automatically to the identifier, and the port number is chosen by the
underlying system:

<CODE>
OtpNode node = new OtpNode("gurka");
</CODE>

</SECTION>


<SECTION><TITLE>Mailboxes</TITLE>

<P>Erlang processes running on an Erlang node are identified by process
identifiers (pids) and, optionally, by registered names unique within
the node. Each Erlang process has an implicit mailbox that is used to
receive messages; the mailbox is identified with the pid of the
process.

<P>Jinterface provides a similar mechanism with the class 
<seealso marker="java/com/ericsson/otp/erlang/OtpMbox">OtpMbox</>, a
mailbox that can be used to send and receive messages asynchronously.
Each OtpMbox is identified with a unique pid and , optionally, a registered 
name unique within the 
<seealso marker="java/com/ericsson/otp/erlang/OtpNode">OtpNode</>. 

<P>Applications are free to create mailboxes as necessary. This is done
as follows:

<CODE>
        OtpMbox mbox = node.createMbox();
</CODE>

<P>The mailbox created in the above example has no registered name,
although it does have a pid. The pid can be obtained from the mailbox
and included in messages sent from the mailbox, so that remote
processes are able to respond. 

<P>An application can register a name for a mailbox, either when the
mailbox is initially created:

<CODE>
        OtpMbox mbox = node.createMbox("server");
</CODE>

<P>or later on, as necessary:

<CODE>
        OtpMbox mbox = node.createMbox();
        mbox.registerName("server");
</CODE>

<P>Registered names are usually necessary in order to start
communication, since it is impossible to know in advance the pid of a
remote process. If a well-known name for one of the processes is
chosen in advance and known by all communicating parties within an
application, each mailbox can send an initial message to the named
mailbox, which then can identify the sender pid.

</SECTION>


<SECTION><TITLE>Connections</TITLE>

<P>It is not necessary to explicitly set up communication with a remote
node. Simply sending a message to a mailbox on that node will cause
the OtpNode to create a connection if one does not already exist. Once
the connection is established, subsequent messages to the same node
will reuse the same connection.

<P>It is possible to check for the existence of a remote node before
attempting to communicate with it. Here we send a ping message to the
remote node to see if it is alive and accepting connections:

<CODE>
        if (node.ping("remote",2000)) {
          System.out.println("remote is up");
        }
        else {
          System.out.println("remote is not up");
       }
</CODE>

<P>If the call to ping() succeeds, a connection to the remote node has
been established. Note that it is not necessary to ping remote nodes
before communicating with them, but by using ping you can determine if
the remote exists before attempting to communicate with it.

<P>Connections are only permitted by nodes using the same security
cookie. The cookie is a short string privided either as an argument
when creating OtpNode objects, or found in the user's home directory
in the file <c>.erlang.cookie</c>. When a connection attempt is made, the
string is used as part of the authentication process. If you are
having trouble getting communication to work, use the trace facility
(described later in this document) to show the connection
establishment. A likely problem is that the cookies are different.

<P>Connections are never broken explicitly. If a node fails or is closed,
a connection may be broken however.

</SECTION>


<SECTION><TITLE>Sending and Receiving Messages</TITLE>

<P>Messages sent with this package must be instances of 
<seealso marker="java/com/ericsson/otp/erlang/OtpErlangObject">OtpErlangObject</>
or one of its subclasses. Message can be sent to processes or pids,
either by specifying the pid of the remote, or its registered name and
node.

<P>In this example, we create a message containing our own pid so the
echo process can reply:

<CODE>
        OtpErlangObject[] msg = new OtpErlangObject[2];
        msg[0] = mbox.self();
        msg[1] = new OtpErlangAtom("hello, world");
        OtpErlangTuple tuple = new OtpErlangTuple(msg);
</CODE>

<P>When we send the message, a connection will be created:

<CODE>
        mbox.send("echo", "gurka@sallad.com", tuple);
</CODE>

<P>And here we receive the reply:

<CODE>
        OtpErlangObject reply = mbox.receive();
</CODE>

<P>Messages are sent asynchronously, so the call to <c>send()</c> returns as
soon as the message has been dispatched to the underlying
communication layer. This means that you receive no indication whether
the operation completed successfully or the remote even existed. If
you need this kind of confirmation, you should wait for a response
from the remote process.

<P>The echo server itself might look like this:

<CODE>
    OtpNode self = new OtpNode("gurka");
    OtpMbox mbox = self.createMbox("echo");
    OtpErlangObject o;
    OtpErlangTuple msg;
    OtpErlangPid from;
    
    while (true) {
      try {
        o = mbox.receive();
        if (o instanceof OtpErlangTuple) {
          msg = (OtpErlangTuple)o;
          from = (OtpErlangPid)(msg.elementAt(0));
          mbox.send(from,msg.elementAt(1));
      }
      catch (Exception e) {
        System.out.println("" + e);
      }
    }
</CODE>

<P>In the examples above, only one mailbox was created on each node.
however you are free to create as many mailboxes on each node as you
like. You are also free to create as many nodes as you like on each
JVM, however because each node uses some limited system resources such
as file descriptors, it is recommended that you create only a small
number of nodes (such as one) on each JVM.

</SECTION>

<SECTION><TITLE>Sending Arbitrary Data</TITLE>

<P>This package was originally intended to be used for communicating
between Java and Erlang, and for that reason the send and receive
methods all use Java representations of Erlang data types. 

<P>However it is possible to use the package to communicate with remote
processes written in Java as well, and in these cases it may be
desireable to send other data types.

<P>The simplest way to do this is to encapsulate arbitrary data in
messages of type 
<seealso marker="java/com/ericsson/otp/erlang/OtpErlangBinary">OtpErlangBinary</>. 
The OtpErlangBinary class can be created from arbitrary Java objects that implement the 
Serializable or Externalizable interface:

<CODE>
        o = new MyClass(foo);
        mbox.send(remote,new OtpErlangBinary(o));
</CODE>

<P>The example above will cause the object to be serialized and
encapsulated in an OtpErlangBinary before being sent. The recipient
will receive an OtpErlangBinary but can extract the original object
from it:

<CODE>
        msg = mbox.receive();
        if (msg instanceof OtpErlangBinary) {
           OtpErlangBinary b = (OtpErlangBinary)msg;
           MyClass o = (MyClass)(b.getObject());
        }
</CODE>

</SECTION>



<SECTION><TITLE>Linking to Remote Processes</TITLE>

<P>Erlang defines a concept known as linked processes. A link is an
implicit connection between two processes that causes an exception to
be raised in one of the processes if the other process terminates for
any reason. Links are bidirectional: it does not matter which of the
two processes created the link or which of the linked processes
eventually terminates; an exception will be raised in the remaining
process. Links are also idempotent: at most one link can exist between
two given processes, only one operation is necessary to remove the
link.

<P>Jinterface provides a similar mechanism. Also here, no distinction is
made between mailboxes and Erlang processes. A link can be created to
a remote mailbox or process when its pid is known:

<CODE>
        mbox.link(remote);
</CODE>

<P>The link can be removed by either of the processes in a similar manner:

<CODE>
        mbox.unlink(remote);
</CODE>

<P>If the remote process terminates while the link is still in place, an
exception will be raised on a subsequent call to receive():

<CODE>
        try {
          msg = mbox.receive();
        }
        catch (OtpErlangExit e) {
          System.out.println("Remote pid " + e.pid() + " has terminated");
        }
        catch (OtpErlangDecodeException f) {
          System.out.println("Received message could not be decoded: " + f);
        }
</CODE>
                
<P>When a mailbox is explicitly closed, exit messages will be sent in
order to break any outstanding links. If a mailbox is never closed but
instead goes out of scope, the objects <c>finalize()</c> method will call
<c>close()</c>. However since Java provides no guarantees about when or even
if finalize() will be called, it is important that your application
explicitely closes mailboxes when they are no longer needed if you
want links to work in a timely manner. 


</SECTION>


<SECTION><TITLE>Using EPMD</TITLE>

<p>Epmd is the Erlang Port Mapper Daemon. Distributed Erlang nodes
register with epmd on the localhost to indicate to other nodes that
they exist and can accept connections. Epmd maintains a register of
node and port number information, and when a node wishes to connect to
another node, it first contacts epmd in order to find out the correct
port number to connect to.

<p>The basic interaction with EPMD is done through instances of 
<seealso marker="java/com/ericsson/otp/erlang/OtpEpmd">OtpEpmd</> class.
Nodes wishing to contact other nodes must first request information 
from Epmd before a connection can be set up, however this is done automatically 
by <seealso marker="java/com/ericsson/otp/erlang/OtpSelf#connect(com.ericsson.otp.erlang.OtpPeer)">OtpSelf.connect()</> when necessary. 

<p>When you use <seealso marker="java/com/ericsson/otp/erlang/OtpSelf#connect(com.ericsson.otp.erlang.OtpPeer)">OtpSelf.connect()</> to connect to an Erlang node, 
a connection is first made to epmd and, if the node is known, a
connection is then made to the Erlang node.

<p>Java nodes can also register themselves with epmd if they want other
nodes in the system to be able to find and connect to them.
This is done by call to method <seealso marker="java/com/ericsson/otp/erlang/OtpEpmd#publishPort(com.ericsson.otp.erlang.OtpLocalNode)">OtpEpmd.publishPort()</>.

<p>Be aware that on some systems (such as VxWorks), a failed node will
not be detected by this mechanism since the operating system does not
automatically close descriptors that were left open when the node
failed. If a node has failed in this way, epmd will prevent you from
registering a new node with the old name, since it thinks that the old
name is still in use. In this case, you must unregister the name
explicitly, by using <seealso marker="java/com/ericsson/otp/erlang/OtpEpmd#unPublishPort(com.ericsson.otp.erlang.OtpLocalNode)">OtpEpmd.unPublishPort()</>

<p>This will cause epmd to close the connection from the far end. Note
that if the name was in fact still in use by a node, the results of
this operation are unpredictable. Also, doing this does not cause the
local end of the connection to close, so resources may be consumed.

</SECTION>


<SECTION><TITLE>Remote Procedure Calls</TITLE>


<P>An Erlang node acting as a client to another Erlang node
typically sends a request and waits for a reply. Such a request is
included in a function call at a remote node and is called a remote
procedure call. Remote procedure calls are supported through the class
<seealso marker="java/com/ericsson/otp/erlang/OtpConnection">OtpConnection</>.
The following example shows how the
<seealso marker="java/com/ericsson/otp/erlang/OtpConnection">OtpConnection</> 
class is used for remote procedure calls:

<CODE>

OtpSelf self = new OtpSelf("client", "hejsan" ); 
OtpPeer other  = new OtpPeer("server@balin"); 
OtpConnection connection = self.connect(other); 

connection.sendRPC("erlang","date",new OtpErlangList());
OtpErlangObject received = connection.receiveRPC(); 

</CODE>

<P><C>erlang:date/0</C> is just called to get the date tuple
from a remote host. 

</SECTION>


<SECTION><TITLE>Compiling and Loading Your Code</TITLE>

<p>In order to use any of the <seealso marker="java/com/ericsson/otp/erlang/package-summary">Jinterface</> 
classes, include the following line in your code:
</P>

<code>
import com.ericsson.otp.erlang.*;
</code>

<p>Determine where the top directory of your OTP installation is. You
can find this out by starting Erlang and entering the following
command at the Eshell prompt:
</P>

<code>
Eshell V4.9.1.2  (abort with ^G)
1> code:root_dir().
/usr/local/otp
</code>

<p>To compile your code, make sure that your Java compiler knows where
to find the file <c>OtpErlang.jar</c> which contains the package.
This is done by specifying an appropriate <c>-classpath</c>
argument on the command line, or by adding it to the <c>CLASSPATH</c>
definition in your <c>Makefile</c>. The correct value for this path is
<c>$OTPROOT/lib/jinterface</c><em>Vsn</em><c>/priv/OtpErlang.jar</c>, where <c>$OTPROOT</c> 
is the path reported by <c>code:root_dir/0</c> in the above example and <em>Vsn</em> is the version of Jinterface, for example <c>jinterface-1.2</c>
</P>

<code>
$ javac -classpath ".:/usr/local/otp/lib/jinterface-1.2/priv/OtpErlang.jar" 
                    myclass.java
</code>

<p>When running your program, you will also need to specify the path to
<c>OtpErlang.jar</c> in a similar way.

<code>
$ java ".:/usr/local/otp/lib/jinterface-1.2/priv/OtpErlang.jar" myclass
</code>

</SECTION>


<SECTION><TITLE>Tracing</TITLE>

<P>Communication between nodes can be traced by setting a system property
before the communication classes in this package are initialized. 

The value system property "OtpConnection.trace" is the default trace
level for all connections. Normally the default trace level is zero,
i.e. no tracing is performed. By setting 
<seealso marker="java/com/ericsson/otp/erlang/OtpConnection">OtpConnection.trace</> 
to some non-zero value, the communication protocol can be shown in more or
less detail. The valid values are:

<list>
<item> 0: no tracing is performed
<item> 1: only ordinary send and reg-send messages are shown
<item> 2: control messages such as link, unlink and exit are shown
<item> 3: connection setup (handshake) is shown
<item> 4: epmd requests are shown
</list>

<P>Each level also includes the information shown by all lower levels.

</SECTION>



</CHAPTER>
