<HTML>
<HEAD>
<TITLE>COMPILER Release Notes (Old)</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<BLOCKQUOTE>
<P>These document describes the release notes for older versions of the <CODE>compiler</CODE> application.

<H2>Compiler 3.0.1.2</H2>
<H3>Fixed errors and malfunctions</H3>

<UL>

<LI>
The compiler would sometimes reorder bit syntax clauses
causing them to be execute in the wrong order.
This has been corrected.
<br>Own Id: OTP-3748<br>
Aux Id: Seq 4954


<LI>
Modules containing long literals string concatenated with
variables would take long time to compile and the beam module
would be unecesserialy large. Both problems have been
corrected.
<br>Own Id: OTP-3831<br>
Aux Id: Seq 5085


<LI>
By default, debug information is no longer included in
beam modules. Use the compiler option <CODE>debug_info</CODE>
to include debug information.
<br>Own Id: OTP-3885


</UL>

<H2>Compiler 3.0.1</H2>
<H3>Improvements and new features</H3>

<UL>

<LI>
Several minor compiler bugs corncerning the bit syntax
were corrected.
<br>Own Id: OTP-3707


</UL>

<H2>Compiler 3.0</H2>
<H3>Known problems</H3>

<UL>

<LI>
Use of recursively defined records causes the compiler to
crash instead of reporting an error.
<br>Own Id: OTP-2677


</UL>
<H3>Fixed errors and malfunctions</H3>

<UL>

<LI>
The Erlang compiler builds lists and tuples in a smarter
way than previous compilers, meaning that literal lists and tuples
practically any size can now be built.
<br>Own Id: OTP-2388<br>
Aux Id: seq 821


<LI>
Using a literal atom in a call to atom_to_list/1 resulted
in a compiled module that could not be loaded. This has been corrected.
<br>Own Id: OTP-3438


</UL>
<H3>Improvements and new features</H3>

<UL>

<LI>
We have made several changes to the garbage collector
and internal memory allocation routines to reduce
memory consumption and memory fragmentation.
Also, the compiler now makes sure that references
to any data that will not be used again will be killed,
so that the garbage collector can discard it as soon
as possible.
(Thanks to Claes Wickstrom at Bluetail who suggested
most of the changes to the garbage collector.)
<br>Own Id: OTP-2375<br>
Aux Id: seq 816, HA81951


<LI>
It is now allowed to use an expression within a pattern,
if the expression uses only numeric or bitwise operators,
and can
be evaluated to a constant at compile-time. E.g.,
<CODE>
case X of
{1+2, T} -&gt; T
end.
</CODE>
<br>Own Id: OTP-3144<br>
Aux Id: OTP-3143


<LI>
There now exists syntax for constructing and matching
binaries. For more infomation, see Extensions to Erlang.
Also, the handling of small binaries (up to 64 bytes) has
been optimised, as well as splitting of binaries.
<br>Own Id: OTP-3376


<LI>
The construction <CODE>??Arg</CODE> for an argument to a macro
expands to a string containing the tokens of the argument,
similar to the <CODE>#arg</CODE> stringifying construction in C.
<br>Own Id: OTP-3425


<LI>
The compiler now supports inlining within a module
(see the compiler documentation). Numerous known
problems and limitations have been corrected, and
the optimisation is better (for instance, tuples
used in cases for grouping are no longer built).
The earlier compiler versions v1 (R5) and v2 (R6)
have been discontinued because there are no longer
any reason to use them.
<br>Own Id: OTP-3672


</UL>


<H2>Compiler 2.1</H2>
<H3>Improvements and new features</H3>

<UL>

<LI>
The old compiler from R5 is included as well as the new compiler.
The new compiler (<CODE>v2</CODE>) is the default. The old compiler
can be chosen by giving a <CODE>v1</CODE> option to the compiler.
The compiler will also read default compiler options from
the ERL_COMPILER_OPTIONS environment variables.
<br>
<p>
The <CODE>v2</CODE> compiler, which is default, generates smaller and
faster code than the <CODE>v1</CODE> compiler, but in one case the
compilation can be extremly slow: on pattern matching on long literal
strings. The <CODE>v2</CODE> compiler in R6A also compiled huge list
and/or tuple literals slowly. The <CODE>v2</CODE> compiler in R6B
compiles these literals much faster.
<br>Own Id: OTP-3363


</UL>
<H2>Compiler 2.0</H2>
<H3>Known problems</H3>

<UL>

<LI>
Use of recursively defined records causes the compiler to
crash instead of reporting an error.
<br>Own Id: OTP-2677


<LI>
All current versions of the Beam compiler (both the <CODE>v1</CODE>
and the <CODE>v2</CODE> versions) have a hard limit on the size of
list and tuple literals in Beam modules. This limit 1024,
which is the number of registers in the Beam virtual machine.
When building a list whose elements are not small integers
or atoms, the compiler generates code that builds all list
elements from left to right (as the Erlang standard prescribes)
saving the built elements in registers. When all elements has
been built, the list itself is built. This effectively limits
the size of a literal list to 1024 elements.
<br>
<p>
This limitation will be removed in a future version of the
compiler.
<br>
<p>
Note 1: This only applies to list literals in Beam modules,
not to list literals read from data files by <CODE>file:consult/X</CODE>
or other means, or lists built dynamically by Erlang code or
BIFs. The only practial limit on the list size is the available
memory.
<br>
<p>
Note 2: Literals list with elements that don't need to be built
beforehand (such as numbers and atoms) can be of any length.
<br>
<p>
Note 3: The same rules apply to tuples.
<br>Own Id: OTP-3367


</UL>
<H3>Fixed errors and malfunctions</H3>

<UL>

<LI>
In earlier Beam releases, the result of the
match operator '=' in a function body was wrong.
For instance, in '<CODE>io:format("~p\n", [[X]=[a]])</CODE>',
the result of the match expression '<CODE>[X]=[a]</CODE>' should
be '<CODE>[a]</CODE>', but in Beam it was '<CODE>a</CODE>'.
This all means that multiple patterns in function bodies
such as '<CODE>[X] = [Y] = [a]</CODE>' would fail with a badmatch exception
in Beam releases before R6.
This has been corrected in the new Beam compiler.
Incorrect code like '<CODE>a = [X] = [a]</CODE>' which depended
on the incorrect behaviour will now fail with a badmatch.
<br>(*** POTENTIAL INCOMPATIBILITY ***)
<br>Own Id: OTP-3176


</UL>
<H3>Improvements and new features</H3>

<UL>

<LI>
Where previously only one comma-separated sequence of guard
tests was allowed, now a guard can be written as a
disjunction of sequences, using
<CODE>;</CODE> as separator. This is syntactic sugar which removes
the bother of writing the same body after several guards.
<br>Own Id: OTP-3182


<LI>
The compiler has been entirely rewritten for this release.
It generally generates smaller and faster code
than the old compiler. The compiler itself, however, may
be slower than the older compiler, depending on the input.
<br>Own Id: OTP-3335


</UL>

<H2>Compiler 1.3</H2>
<H3>Known problems</H3>

<UL>

<LI>
When the macro <code>?MACHINE</code> is encountered by the
compiler, it
is expanded to the machine which is running the compiler,
not the machine for which the code is compiled. The latter is
almost always more useful.
<br>Own Id: OTP-2517


<LI>
<CODE>c:c(File, 'P')</CODE> does produce a .P file, but yields an
ugly error message in the process.
<br>Own Id: OTP-3054


</UL>
<H2>Compiler 1.3</H2>
<H3>Fixed errors and malfunctions</H3>

<UL>

<LI>
Use of macros with circular definitions now gives an
error message,
instead of causing the compiler (or <CODE>epp</CODE>) to
hang or crash. (Checking is not done for macros which
exploit the fact that macros may end in a lone '<CODE>?</CODE>' -
use of this feature is not recommended.)
<br>Own Id: OTP-1398<br>
Aux Id: OTP-1103,OTP-1180


<LI>
Some error conditions when compiling (for example, attempting
to create a literal tuple with more than 256 elements in JAM)
were not reported as errors, but only printed on the terminal,
therefore making it appear as if the compilation succeeded.
They are now reported properly.
<br>Own Id: OTP-2620


<LI>
BEAM only: the beam compiler generates wrong code when there is
several function clauses with a common first part of a pattern
and
then a different second part of the pattern where this second
part of the pattern is built on the heap. Examples of code that
is generated wrong are:
<pre>
-module(beamfel3).
-export([handle_cast/2]).
-record(state,{e1,e2}).
<br>
handle_cast({a,DpId},State) when State ==
#state{e1=true,            
e2=a} -&gt;
process_info(DpId);
<br>
handle_cast({a,DpId},State) when State ==
#state{e1=true,            
e2=b} -&gt;
process_info(DpId).
<br>
</pre>
or like this:
<pre>
-module(beamfel2).
-export([f/2]).
<br>
f({a,DpId},16#7fffffff) -&gt;
process_info(DpId);
<br>
f({a,DpId},16#80000000) -&gt;
process_info(DpId).
<br>
</pre>
This codegeneration error could cause the Erlang emulator to terminate
with the message "Overrun heap and stack ...".
This is now corrected. This has also been corrected in patch erl_077 
for
OTP R4B.
<br>Own Id: OTP-2821<br>
Aux Id: Seq 1271


<LI>
Failing parse transforms were confusing; now the error
message is better.
<br>Own Id: OTP-2839


<LI>
BEAM only: If the '<CODE>&lt;</CODE>' operator was used in a body context
(<CODE>Bool = Expr1 &lt; Expr</CODE>), the compiler could crasch
or generate incorrect code.  This has been corrected.
<br>Own Id: OTP-2871<br>
Aux Id: seq 1343


</UL>
<H3>Improvements and new features</H3>

<UL>

<LI>
Two functions have been added to the <CODE>compile</CODE>
module: <CODE>compile:forms/1</CODE> and
<CODE>compile:forms/2</CODE>, which are analogous to
<CODE>compile:file/[1,2]</CODE>, but take a list of forms as
their first argument (such as is returned by the
function <CODE>epp:parse_file/3</CODE>). The option
<CODE>binary</CODE> is implicit; i.e., a binary is produced,
never an object code file. If a listing file is
requested (e.g., using the option 'E'), the module
name is taken as the file name.
<br>Own Id: OTP-2621<br>
Aux Id: seq 961


<LI>
For two kinds of errors, error messages from the
compiler/linter/scanner now report the errors at the line
where they occurred instead of at the end of the file:
unterminated atoms and strings; and undefined
functions.
(For unterminated atoms and strings, the line
does not point out the start of the string, but the
line where scanning of the current form or expression began.)
<br>Own Id: OTP-2726<br>
Aux Id: seq 1156


<LI>
The compiler now evaluates expressions at
compile-time when their values are known, also eliminating
dead code from <CODE>if</CODE> and <CODE>case</CODE> expressions when only
one branch can ever be selected.
<br>Own Id: OTP-2820<br>
Aux Id: OTP-2794 WP37


<LI>
For a node A to be able to create a fun, send it to a node B
and let it execute there, it used to be the case that
the object code loaded in both nodes had to be produced
by the same compilation.
Now it is possible to use object code files produced from
the same Erlang source file, but compiled on different
occasions.
The compiler attempts to ensure that a fun produced by
one version of a module cannot be used with a different
version of the module if the source code of the modules differ.
<br>Own Id: OTP-2842<br>
Aux Id: Seq 1233


<LI>
A new construction has been added to the language: the
match operator (i.e., the = operator) can now be used
within patterns. For example, the following is now valid:
<pre>	f({'+',X,Y}=T) -&gt; {X+Y,T}.
</pre>
This often makes it possible to avoid rebuilding a term
which is already present but has no name, since it was
matched with a complex pattern. It also makes it possible
to rewrite the construction
<pre>	f(X) when X == #rec{x=1, y=a} -&gt; ...
</pre>
as
<pre>	f(#rec{x=1, y=a} = X) -&gt; ...
</pre>
In the absence of optimization for the former case, the
latter case is more efficient.
<br>
The new language feature uses no new addition to the
virtual Erlang machine, which means that a compiled module
using the new feature can be used in an old Erlang release,
provided it is not incompatible for some other reason.
<br>
The abstract representation of Erlang source code has been
augmented accordingly.
<br>Own Id: OTP-2983


<LI>
A new option <CODE>asm</CODE> expects the input file to be
a previously produced Erlang assembler file (default
file suffix ".S"). Note that the format of assembler files
is not documented, and may change between releases - this
option is primarily for internal debugging use.
The <CODE>asm</CODE> option only works for BEAM.
<br>Own Id: OTP-2988


<LI>
The <CODE>export_all</CODE> compilation option no longer produces one
warning for each function defined in a module; it produces
one single warning (since <CODE>export_all</CODE> shouldn't be used
in production code).
<br>Own Id: OTP-3020


<LI>
When compiling, warnings for functions which are not used
are now given also for functions which call only themselves.
<br>Own Id: OTP-3021<br>
Aux Id: OTP-1007


<LI>
New compiler options have been added for stopping compilation
and outputting the code at certain points. 'E' still produces
the last stage of Erlang code transformation. New options
are <CODE>dexp</CODE> and <CODE>dpe</CODE>, which produce files with
extension "<CODE>expand</CODE>" and "<CODE>parteval</CODE>",
respectively. To pass these options to the compiler via
<CODE>erlc</CODE>, prefix them with a '+'. For Beam, the new
options <CODE>dcg</CODE> and <CODE>dopt</CODE> produce files with
extension "<CODE>codegen</CODE>" and "<CODE>optimize</CODE>", respectively.
<br>Own Id: OTP-3040


<LI>
Due to an oversight, the following improvements were
left out of the documentation in previous releases:
<p>
Two adjacent literal string tokens are concatenated into
one string at compile-time (actually, by the parser).
For example, <CODE>"abc" "def"</CODE> becomes <CODE>"abcdef"</CODE>.
<p>
The compiler directives <CODE>-include(File)</CODE> and
<CODE>-include_lib(File)</CODE> are available for including header
files.
<br>Own Id: OTP-3051


<LI>
A new construction is allowed in patterns, namely a literal
string as the first operand of the ++ operator. Example:
<pre>	f("prefix" ++ L) -&gt; ...
</pre>
This is syntactic sugar for the equivalent, but harder to read
<pre>	f([$p,$r,$e,$f,$i,$x | L]) -&gt; ...
</pre>
<br>Own Id: OTP-3069

</UL>

<H2>Compiler 1.2.1</H2>
<H3>Fixed errors and malfunctions</H3>

<UL>

<LI>
An incorrect reference to <CODE>asm</CODE> is removed from the
<CODE>compile</CODE> reference manual.
<br>Own Id: OTP-2619


</UL>
<H3>Improvements and new features</H3>

<UL>

<LI>
It used to be the case that ?P and ?'P' (i.e., macro names
starting with an uppercase letter) were references
to different macros. This had the consequence that the
form without quotes, which is the natural form to use,
could not be set from outside the source file (for example,
using the -D option to 'erlc'). Now, ?P and ?'P' have been
made equivalent, so that "erl -DP=1" causes both ?P and
?'P' to expand to 1.
<br>Own Id: OTP-2608


</UL>
<H2>Compiler 1.2</H2>
<H3>Fixed errors and malfunctions</H3>

<UL>

<LI>
Giving floating points attributes in module attributes 
(like <CODE>-vsn(1.0)</CODE>) used to crash the Erlang compiler.
This has been corrected.
<br>Own Id: OTP-2141<br>
Aux Id: seq 623, OTP-2302


</UL>
<H3>Improvements and new features</H3>

<UL>

<LI>
The <CODE>fast</CODE> option has been removed.
<br>
The object code format is partly documented
(see the <CODE>compile</CODE> module).
With the help of this documentation, tools can be written
to inspect, change, delete, or add module attributes.
Also, function call tracing can be enabled or disabled
by changing a single bit in the header of the object code.
<br>Own Id: OTP-2262<br>
Aux Id: seq 718


<LI>
The escape sequences \s in strings and $\s outside strings
now give the ASCII code for space.  It is recommended to
use $\s instead of dollar followed by space, for readability
reasons.  Note that $\s in earlier releases was equivalent
to $s.
<br>Own Id: OTP-2522


</UL>

<H2>R3B02 (Compiler 1.1.5)</H2>
<H3>Fixed errors and malfunctions</H3>

<UL>

<LI>
A <CODE>fun</CODE> could not be used in a record initializer.
<br>Own Id: OTP-2173<br>
Aux Id: seq 649


<LI>
The compiler sometimes failed to compile modules where conditions
were invariably false (e.g. <CODE>case 1 of [X] -&gt; ...</CODE>).
<br>Own Id: OTP-2330<br>
Aux Id: seq 791


<LI>
Using a literal atom as case expression and more than five
matching atoms, the compiler would generate a module which
cannot be loaded. This has been corrected.
<br>Own Id: OTP-2380<br>
Aux Id: seq 701,HA77209


</UL>
<H2>R3B (Compiler 1.1.4)</H2>
<H3>Improvements and new features</H3>

<UL>

<LI>
The BEAM compiler will give a diagnostic if the trace and
fast options are combined (earlier it silently ignored
the trace flag, producing fast code which couldn't trace BIFs).
<br>(*** POTENTIAL INCOMPATIBILITY ***)
<br>Own Id: OTP-1954<br>
Aux Id: seq 442


</UL>
<H2>R3A (Compiler 1.1.3)</H2>
<H3>Fixed errors and malfunctions</H3>

<UL>

<LI>
An error in the beam-compiler which caused an internal error
when compiling e.g. a list match like this: <br>
<CODE>[H | T] = foo(), </CODE> where H is not used in the function
is corrected.
<br>Own Id: OTP-1476


<LI>
In the Beam compiler, the calculation of heap usage for a
<CODE>case</CODE> or <CODE>receive</CODE> statement was overly pessimistic
in some cases, resulting in the allocation of unnecessary large
process heaps or in the extreme case a load error for the module
("Error while loading -PASS 2-").
This has been corrected.
<br>Own Id: OTP-1713


<LI>
The beam-compiler is corrected regarding a catch inside a
catch (in the same function). All exits ended up in the 
outermost catch, which was wrong.
<br>Own Id: OTP-1834<br>
Aux Id: SEQ 400


</UL>
<H3>Known problems</H3>

<UL>

<LI>
Giving floating points attributes in module attributes 
(like <code>-vsn(1.0)</code>) crashes the Erlang compiler.
<br>Own Id: OTP-2141


</UL>

<A NAME="2"><!-- Empty --></A><H2>2 Compiler 1.1.2</H2><P> <A NAME="2.1"><!-- Empty --></A><H3>2.1 Incompatibilities with Compiler 1.1.1</H3><P>Due to corrections listed below, all BEAM code must be
recompiled (see also release notes for ERTS).
<A NAME="2.2"><!-- Empty --></A><H3>2.2 Fixed bugs and malfunctions</H3><P><UL>
<LI>     Wrong restart of send at busy or garbage collect (BEAM, fast
         compiled code).
         <BR>
Own Id:OTP-1420
        <BR>
<LI>     Bad arithmetic in guard fails instead of matching the next
         clause (BEAM).
         <BR>
Own Id:OTP-1422
        <BR>
</UL>
<A NAME="2.3"><!-- Empty --></A><H3>2.3 Known bugs and problems</H3><P><UL>
<LI>    The BEAM compiler terminates with error <CODE>beam_asm_int: EXIT</CODE> 
        when a list match is performed as in <CODE>[H| T] = foo()</CODE>, in case 
        variable <CODE>T</CODE> is subsequently used, while <CODE>H</CODE> is not.
        The work-around is to write <CODE>T = tl(foo())</CODE> instead.
        <BR>
Own Id: OTP-1476
        <BR>
</UL>
<A NAME="3"><!-- Empty --></A><H2>3 Compiler 1.1.1</H2><P> <A NAME="3.1"><!-- Empty --></A><H3>3.1 Incompatibilities with Compiler 1.1</H3><P>Due to corrections listed below, all BEAM code must be
recompiled (see also release notes for ERTS).
<A NAME="3.2"><!-- Empty --></A><H3>3.2 Fixed bugs and malfunctions</H3><P><UL>
<LI>     Correction of register allocation error in creation of tuples
         in guards in BEAM. 
         <BR>
Own Id:OTP-1390
        <BR>
<LI>     Correction of compiler error for BEAM which caused <CODE>ig</CODE> 
         to generate erroneous code (error in nested case statements).
         <BR>
Own Id:OTP-1392
         <BR>
Aux Id:HA48119
        <BR>
</UL>
<A NAME="4"><!-- Empty --></A><H2>4 Compiler 1.1</H2><P> <A NAME="4.1"><!-- Empty --></A><H3>4.1 Improvements and new features</H3><P><UL>
<LI>To simplify maintenance and cross compilations the two compiler
directories, compiler_jam and compiler_beam, has been merged into a
single compiler directory. Most modules names have been changed to
avoid confusion and name collisions. The only user visible change is
that the compilation target (jam or beam) can be specified in the list
of arguments. E.g.<BR>
<PRE>compile:file(foo, [beam, verbose, report]).</PRE>

        </UL>
<A NAME="4.2"><!-- Empty --></A><H3>4.2 Incompatibilities with Compiler 1.0</H3><P> -
<A NAME="4.3"><!-- Empty --></A><H3>4.3 Fixed bugs and malfunctions</H3><P><UL>
<LI>Compiler crashed on &#34;silly&#34; record update like this:<BR>
<PRE>-record(bar, {hello}).

compilerCrash() -&#62;
     R1 = #bar{},
     R2 = R1#bar{},   % &#60;--- This causes the compiler to crash with the not_ok.</PRE>
         Own Id:OTP-1204,OTP-1208
        <BR>
<LI>The compiler does not check that record fields in a match are
         unique. Example:<BR>
<PRE>-module(compiler_6_SUITE).

-record(foo, {bar}).

f() -&#62;
    #foo{bar = X,bar = Y} = x,
    Y.

56&#62; c(compiler_6_SUITE).
*** unset variable:'Y' in line:7</PRE>
         <CODE>bar</CODE> is repeated twice in the above example and the compiler
         does not detect that as an error which causes the assignment of <CODE>Y</CODE> to be silently ignored ...
         <BR>
Own Id:OTP-1231
<BR>
</UL>
<A NAME="5"><!-- Empty --></A><H2>5 Compiler 1.0.1</H2><P> <A NAME="5.1"><!-- Empty --></A><H3>5.1 Improvements and new features</H3><P> -
<A NAME="5.2"><!-- Empty --></A><H3>5.2 Incompatibilities with Compiler 1.0</H3><P> -
<A NAME="5.3"><!-- Empty --></A><H3>5.3 Fixed bugs and malfunctions</H3><P><UL>
<LI>     The compiler no longer crashes on too long atoms (&#62; 255).
         <BR>
Own Id: OTP-1012
        <BR>
<LI>     The compiler <CODE>erl_lint</CODE> did earlier assume that some
         language constructs aways resided on the same line in the 
         source code which caused a white space to be significant
         when determing an error or not. This is corrected.
         <BR>
Example:
         <BR>
<PRE>-module(test).
-compile(export_all).
-record(test, {a,b}).
rectest(R) when record(R, test) -&#62;
    ok.  
rectest2(R) when record(R,
                        test) -&#62;
    ok.  
 
(test@etxbc29)3&#62; c(test).
./test.erl:7: illegal guard expression
          </PRE> 

         Own Id: OTP-1077
        <BR>
<LI>     The compiler crashes on unsafe variable in nested case.
         This is corrected.
         <BR>
Own Id: OTP-1104
        <BR>
</UL>
<A NAME="6"><!-- Empty --></A><H2>6 Compiler 1.0</H2><P> <A NAME="6.1"><!-- Empty --></A><H3>6.1 Improvements and new features</H3><P>  <P><UL>
<LI>     A new include directive <CODE>-include_lib()</CODE> is introduced. 
         Example:
         <BR>
<PRE>-include_lib(&#34;mnesia/include/mnemosyne.hrl&#34;).
            </PRE>
         This instructs the compiler (preprocessor) to look for the 
         directory where the application called <CODE>mnesia</CODE> is 
         installed and then looks in the subdirectory <CODE>include</CODE>
         for the file <CODE>mnemosyne.hrl</CODE>. The preprocessor first
         looks in the orinary preprocessor search path to allow
         explicit overloading of the include files.
        <BR>
<LI>     The new compiler options <CODE>{i, IncludeDir}</CODE> and {d, Def}
         are introduced.
        <BR>
</UL>
<A NAME="6.2"><!-- Empty --></A><H3>6.2 Incompatibilities with Compiler P1C</H3><P>     There are two new reserved words <CODE>let</CODE> and <CODE>query</CODE>.
<P><UL>
<LI>     <CODE>let</CODE> will be used in the future when a language construction similar to let in Lisp will be implemented.
        <BR>
<LI>     <CODE>query</CODE> is used when making queries to Mnesia tables 
         with the Mnemosyne query language.
        <BR>
</UL>
<A NAME="6.3"><!-- Empty --></A><H3>6.3 Fixed bugs and malfunctions</H3><P>-
</BLOCKQUOTE>
<CENTER>
<HR>
<FONT SIZE=-1>
Copyright &copy; 1991-99
<A HREF="http://www.ericsson.se">Ericsson Utvecklings AB</A><BR>
<!--#include virtual="/ssi/otp_footer.html"-->
</FONT>
</CENTER>
</BODY>
</HTML>




