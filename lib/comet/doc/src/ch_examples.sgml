<!doctype chapter PUBLIC "-//Stork//DTD chapter//EN">
<!-- 
 ``The contents of this file are subject to the Erlang Public License,
 Version 1.1, (the "License"); you may not use this file except in
 compliance with the License. You should have received a copy of the
 Erlang Public License along with this software. If not, it can be
 retrieved via the world wide web at http://www.erlang.org/.
 
 Software distributed under the License is distributed on an "AS IS"
 basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
 the License for the specific language governing rights and limitations
 under the License.
 
 The Initial Developer of the Original Code is Ericsson Utvecklings AB.
 Portions created by Ericsson are Copyright 1999, Ericsson Utvecklings
 AB. All Rights Reserved.''
 
     $Id$
-->
<chapter>
  <header>
    <title>Examples</title>
    <prepared>Jakob Cederlund</prepared>
    <docno></docno>
    <date>2000-05-05</date>
    <rev>A</rev>
    <file>ch_examples.sgml</file>
  </header>

  <p>
    Detailed examples on how to use Comet

  <section><title>Comet Examples</title>

    <p>
      This chapter describes in detail som examples on Comet usage; the
      simpler ones first and the most advanced last.
    <p>
      Four examples are given:
    <list>
      <item><p>Browsing to a specified address</item>
      <item><p>Opening Excel, inserting some data, showing a graph</item>
      <item><p>Calling a function in a C++ library</item>
      <item><p>Using ADO (ActiveX Data Objects) to read and update data from
	  an SQL Server database.</item>
    </list>
    <p>
      Source code for these are included in the distribution, in the
      directory <c>comet/examples</c> .
    <p>
      The abbreviations VB and VBA are used for Visual Basic and
      Visual Basic for Applications.
  </section>
      
  <section><title>Requirements</title>
    <p>
      The first example requires that Internet Explorer 4.0 or later
      is installed.
    <p>
      Example two requires Excel from Office 97 or Office 2000.
    <p>
      The last example can be run as it is, but to modify the
      COM-library, Visual C++ 5.0 or later is required.
  </section>

  <section><title>Example One, Opening a Browser to a Specific URL</title>
    <p>
      This example shows how to open a browser (Internet Explorer),
      and navigate through it to a specific address.
    <p>
      To get the COM interface for the browser, we use a tool such as
      OLE/COM Object Viewer, which is included in Microsoft's Windows
      Platform SDK, Visual C and Visual Basic.
    <p>
      Checking the interface for Internet Explorer, we find a couple
      of things that we need. First, we need the class ID. Then we
      need the name and parameter list of the funcions and properties
      required to create and use a browser.
    <p>
      Since starting a browser is not a performance-critical task, we
      can use the slowest and safest way to do it from Erlang.  This
      means starting the <c>erl_com</c> as a port process, and using
      the IDispatch interface to access Internet Explorer.
    <p>
      Although Internet Explorer provides a dual interface, (that is
      an interface with both a method table and an
      IDispatch-interface), the IDispatch interface is safer and
      slower. Giving it a bad parameter list, returns an error code,
      rather than a core dump.
    <p>
      To use a COM object, we have to start the server (which starts
      the port) and start a thread. Then we can create the object, and
      do what we want with it.
    <p>
      To be able to use constants, we put the source in a module,
      rather than call it interactively in the Erlang shell.
    <p>
    <codeinclude file="examples/xc_gen.erl">
    <p>
      The internet explorer application has a dispatch interface, that
      implements the IWebBrowser interface. There are a lot of
      methods. We use the <c>Navigate</c> method to open a specific
      URL, and the <c>Visible</c> property to show the browser. (By
      default, the browser is created invisible, like other Microsoft
      programs used from COM.)

  </section>
  <section><title>Example Two, Making a Graph in Excel</title>
    <p>
      In this example, we also start an instance of the Excel
      application. We use the program name "Excel.Application", which
      can be used instead of a class ID. This selects the Excel that
      is installed; Excel from Office 97 or Office 2000.
    <p>
      The easiest way to do anything with Excel is to first record a
      VBA macro. The resulting VBA macro is shown in figure 1. This
      macro is manually rewritten a bit to make it simpler. We try it
      out, and the result is shown in figure 2.
    <p>
      Now, to perform this into Erlang, we have two choices: either we
      can call the VB code as a subroutine using COM from Erlang, or
      we can reimplement the VB macro in Erlang. Since this is a
      user's guide, we of course choose the latter.
    <p>
      To get to the interfaces, we use OLE/COM Object Viewer, and get
      the IDL for Excel. There is an Excel type library available.  We
      do not want all of it because it is huge. We just pick the
      needed interfaces, which are <c>_Application</c>, <c>_Graph</c>
      and <c>_Range</c>. We also extract some enums, which are
      constants used for parameters in the COM calls.
    <p>
      There are some tricky issues when calling COM from Erlang
    <p>
      First, VB handles releasing of COM interfaces implicitly.
      Erlang and COM does not do this, so we have to make calls to
      <c>erl_com:release/1</c> for every interface we get. For
      instance, every <c>_Range</c> we get from the property
      <c>_Application.Range</c>, has to be released. We do this in the
      helper function <c>data_to_column/3</c>.
    <p>
      Secondly, when an interface is returned, it is returned as an
      integer. This integer is actually an index into an interface
      array contained in the <c>erl_com_drv</c> port program. When
      calling functions in <c>erl_com</c>, we have to provide both the
      pid and the thread number, so there is a helper function
      <c>erl_com::package_interface/2</c>, that repackages the
      interface integer with given thread or other interface. When
      giving the interface as a parameter to a COM function (through
      <c>erl_com:call</c> or <c>erl_com:invoke</c>), however, the
      interface should be converted to a pointer, which is done with
      the tuple notation for COM types: <c>{vt_unknown,
      Interface}</c>.
    <p>
      When Excel is started, we execute a series of Excel commands to
      enter data and to draw a graph. The commands are translated from
      a VBA macro that we got using Excel's standard macro recorder.
    <p>
      We use some constants that are needed for the Excel commands.
      These are taken from Visual Basic's code generation from the
      Excel interfaces. Although these can be fetched from Excel using
      COM, <c>erl_com</c> does not yet support this. (Future releases
      will include code-generation that will greatly simplify using
      big COM-interfaces.
    <p>
    <codeinclude file="examples/xc.erl">
    <p>
      Now, from version 1.1 of comet, there is a possibility to
      generate code stubs that wrapps the <c>erl_com</c> calls in
      shorter and clearer names. If we use <c>erl_com:gen_typelib(X,
      dispatch)</c> to generate files, where X is an interface for an
      Excel object, we have a more readable form for the above:
    <p>
    <codeinclude file="examples/xc_gen.erl">
    <p>
      To use the code above, we have to generate Erlang stub modules
      for a lot of interfaces. Checking with the OLE/COM viewer, we
      see that Excel uses both it's own type library, and a common
      library for office programs. We generate these. We use an object
      <c>application</c> a lot, however that name is used by another
      module in OTP. So we generate specifically the "_Application"
      interface, with a prefix "x", to easily use it. Now the
      interface for "_Application" is in the module
      <c>xapplication</c>.
    <p>
      When we use the functions, we take care to match every
      call. This is to catch errors early, remember erl_com returns
      errors in a <c>{com_error, ...}</c> tuple. Successful
      <c>invoke</c> and <c>property_put</c> returns <c>[]</c> and
      <c>0</c>, respectively.
  </section>
  <section>
    <title>Example three, calling a COM object in C++</title>
    <p>To be done.
  </section>
  <section>
    <title>Example four, using ActiveX Data Objects from Erlang</title>
    <p>
      ActiveX Data Objects, or ADO for short, is Microsoft's new
      components for data access, using either Ole-DB or ODBC. They
      provide a nice COM wrapper for accessing SQL databases such as
      SQL Server, Oracle and Sybase.
    <p>
      The following code snippets uses generated code to access data
      on SQL server, in the example database "PUBS". For information
      on ADO, refer to Microsoft documentation.
    <p>
    <codeinclude file="examples/ado.erl">
    <p>
      ADO is a nice way of accessing databases from a windows
      platform. The example shows both reading and changing data on
      the database. The code is more or less taken from Microsoft's
      documentation on ADO.
  </section>
</chapter>






