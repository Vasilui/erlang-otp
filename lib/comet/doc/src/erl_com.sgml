 <!doctype erlref PUBLIC "-//Stork//DTD erlref//EN">
 <!-- 
  ``The contents of this file are subject to the Erlang Public License,
  Version 1.1, (the "License"); you may not use this file except in
  compliance with the License. You should have received a copy of the
  Erlang Public License along with this software. If not, it can be
  retrieved via the world wide web at http://www.erlang.org/.

  Software distributed under the License is distributed on an "AS IS"
  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
  the License for the specific language governing rights and limitations
  under the License.

  The Initial Developer of the Original Code is Ericsson Utvecklings AB.
  Portions created by Ericsson are Copyright 1999, Ericsson Utvecklings
  AB. All Rights Reserved.''

      $Id$
 -->
 <erlref>
   <header>
     <title>erl_com
     <prepared>Jakob Cederlund
     <responsible>Jakob Cederlund
     <docno>
     <approved>
     <checked>
     <date>2000-05-05
     <rev>A
     <file>erl_com.sgml
   </header>
   <module>erl_com</module>
   <modulesummary>Comet gen_server with API to Erlang COM client.</modulesummary>
   <description>
     <p>
       The erl_com module is a gen_server that exposes an API to the port
       program and port driver that is used to call COM services from Erlang.
     <p>
       There is a mapping between types in Erlang and types in COM. The following
       table shows how Erlang types are converted by the port program to COM types.
     <pre>


 COM type	Erlang type		Comment
 --------	-----------		-------
 VT_I4		integer()
 VT_U4		integer()
 VT_BOOL		true | false
 VT_BSTR		string()		Strings are 
					 translated between
					 Ascii and Unicode
 VT_DATE		{integer(), integer(), integer()}	
					 Same format as returned 
					 from now()
		 {{Year, Month, Day}, {Hour, Min, Sec}}
					 Date and time, 
					 with integers in tuples
 VT_PTR		{vt_*, out}		Any output parameter, 
					 including return value
 VT_I1		{vt_i1, integer()}
 VT_U1		{vt_u1, integer()}
 VT_I2		{vt_i2, integer()}
 VT_U2		{vt_u2, integer()}
 VT_UNKNOWN	integer()		Should be sent to 
					 package_interface
 VT_DISPATCH	integer()		Should be sent to 
					 package_interface
 other types	unsupported

    </pre>
    <p>
      Some of the internal Erlang types map to types in COM. Most types in
      COM, however, have no corresponding type in Erlang. In these cases, a
      special tuple is used, of the form <c>{ComType, Value}</c>, where
      <c>ComType</c> is the corresponding type-name as defined in <c>ole2.h</c>
      in the Microsoft Windows SDK.
  </description>
  
  <funcs>

     <func>
       <name>start_driver() -> {ok, Pid}</name>
       <fsummary>Starts the server and loads a port driver.</fsummary>
       <type>
	 <v>Pid = pid()</v>
	 <v>ServerName = {local, atom()} | {global, atom()}</v>
       </type>
       <desc>
	 <p>
	   Starts a new server, and initializes the COM port. The port is
	   loaded as a port driver. This is the most efficient way to use
	   COM, since the com port resides in the same process as the Erlang
	   emulator. However this also means that crashing COM-objects will
	   bring down the emulator.
	 <p>
	   The server can be started with or without a registered name. There
	   is no advantage of having two servers on the same node.
	 <p>
	   This way to launch Comet should only be used in two situations:
	 <list>
	   <item><p>When the COM servers are in separate processes, where
	   they will not bring down the emulator in case of a crash. </item>
	   <item><p>When the COM server is well-known and unlikely to crash,
	   and the overhead of using a separate port process is
	   unacceptable.</item>
	 </list>
       </desc>
     </func>

     <func>
       <name>start_process() -> {ok, Pid}</name>
       <name>start_process(ServerName) -> {ok, Pid}</name>
       <fsummary>Starts the server and starts a port program (in a separate
       process).</fsummary>
       <type>
	 <v>Pid = pid()</v>
	 <v>ServerName = {local, atom()} | {global, atom()}</v>
       </type>	
       <desc>
	 <p>
	   Starts a new server, and initializes the COM port.
	 <p>
	   This function starts the COM port as a port-program, in a
	   separate process. The erl_com gen_server uses (as usual in
	   Erlang), a pipe to communicate with the port. This has the
	   benifit that a crash in the COM port, will not crash the emulator.
	 <p>
	   Each <c>erl_com</c> starts a separate port-program.
	 <p>
	   The server can be started with or without a registered name.
	 <p>
	   Normally, only one <c>erl_com</c> server is started on a node,
	   with possibly several threads for several clients. The
	   only reason to start two servers on the same node is if one might
	   crash, then the other will keep running.
	 <p>
	   This way to launch Comet should be used when:
	 <list>
	   <item><p>The COM server is not 100% certain and crashproof.</item>
	   <item><p>The overhead of using a separate port process
	   is acceptable.</item>
	 </list>
	 <p>
	   Since this way is safer, it is the preferred way of using
	   Comet.
       </desc>
     </func>

     <func>
       <name>stop(ServerRef) -> ok | Error</name>
       <fsummary>Stops the server.</fsummary>
       <type>
	 <v>ServerRef = Name | {Name, Node} | {global, Name} | Pid</v>
	 <v>Name = atom()</v>
	 <v>Node = atom()</v>
	 <v>Pid = pid()</v>
	 <v>Thread = integer()</v>
	 <v>Error = {error, Errcode}</v>
	 <v>Errcode = string()</v>
       </type>
       <desc>
	 <p>
	   Shuts the <c>erl_com</c> server down. This will stop any threads.
	   Interfaces should be released before.
	 <p>
	   (Remember COM has no garbage collection!)	
       </desc>
     </func>

     <func>
       <name>new_thread(ServerRef) -> ComThread | Error</name>
       <fsummary>Creates a new Windows thread for COM execution.</fsummary>
       <type>
	 <v>ComThread = {com_thread, ServerRef, Thread}</v>
	 <v>Thread = integer()</v>
	 <v>Error = {error, Errcode}</v>
	 <v>Errcode = string()</v>
       </type>
       <desc>
	 <p>
	   Creates a new Windows thread that can be used to create and
	   manipulate COM objects. This must be done after
	   <c>erl_com</c> is started. At least one thread has to be created.
	 <p>
	   To allow COM calls to take time without blocking the emulator,
	   <c>erl_com</c> allows multi-threaded execution. The maximum number
	   of threads is 60. However, creating more than a few is not
	   useful for practical reasons.
	 <p>
	   When a COM-thread is created, it is suspended with a select function
	   (which is called WaitForMultipleObjects in the Win32 API).
	   Calling any COM-functions from the thread, is done by
	   setting up a parameter buffer and signaling an event, that
	   wakes up the thread.
	 <p>
	   The return value is a tuple that includes <c>Thread</c>, a
	   thread index that is an integer between 0 and 60, which is
	   unique for each thread, and allocated incrementally. Thread
	   index values will be reused if a thread is ended.
       </desc>
     </func>

    <func>
       <name>end_thread(ComThread) -> ok | Error</name>
       <fsummary>Ends a Windows thread in Comet.</fsummary>
       <type>
	 <v>ComThread = {com_thread, ServerRef, Thread}</v>
	 <v>Thread = integer()</v>
	 <v>Error = {error, Errcode}</v>
	 <v>Errcode = string()</v>
       </type>
       <desc>
	 <p>
	   Ends a thread previously created with <c>new_thread</c>. If
	   the thread has any interfaces, these must be released before
	   the thread is ended, otherwise resource leakage can occur.
	   (Remember COM has no garbage collection!)	
	 <p>
	   The thread is signaled and will exit. The thread index will be
	   marked as available, internally in the port program.
       </desc>
    </func>

    <func>
      <name>create_object(ComThread, Class, Ctx) -> ComInterface | Error</name>
      <name>create_object(ComThread, Class, RefID, Ctx) -> ComInterface | Error</name>
      <name>create_dispatch(ComThread, Class, Ctx) -> ComInterface | Error</name>
      <fsummary>Creates a COM object.</fsummary>
      <type>
	<v>ComThread = {com_thread, ServerRef, Thread}</v>
	<v>Class = string()</v>
	<v>Ctx = integer()</v>
	<v>Thread = integer()</v>
	<v>Error = {error, Errcode}</v>
	<v>Errcode = string()</v>
	<v>ComInterface = {com_interface, ServerRef, Thread, InterfaceNum}</v>
	<v>InterfaceNum = integer()</v>
      </type>
      <desc>
	<p>
	  This function creates a COM object. It calls the Win32 API function, 
	  <c>CoCreateFunction</c>. Refer to Windows documentation and COM books.
	  The string <c>Class</c> can be either a GUID for a class, or
	  a COM program string. Values for the <c>Ctx</c> are defined
	  in <c>erl_com.hrl</c>.
	<p>
	  When successful, this function creates a COM object, and returns a tuple
	  <c>ComInterface</c>, which is a handle for the object, that is used for
	  calling methods, and releasing the object.
	<p>
	  In the case of an error, the COM error code is returned as part of the
	  <c>Errcode</c> string, as a hexadecimal number.
	<p>
	  The <c>create_dispatch</c> variant creates an object with the
	  <c>IDispatch</c> interface. The interface wanted can be specified in
	  the <c>RefID</c> parameters. The default is <c>IUnknown</c>.
      </desc>
    </func>
    <func>
      <name>query_interface(ComInterface, Iid)</name>
      <fsummary>Get a COM interface from another.</fsummary>
      <type>
	<v>Iid = string()</v>
      </type>
      <desc>
	<p>
	  Calls <c>query_interface</c> on the given interface. Note that in COM,
	  an object is also considered an interface.
	<p>
	  This function is used to see what interfaces an object implements
	  and to do down-casting.
      </desc>
    </func>
    <func>
      <name>release(ComInterface)</name>
      <fsummary>Release a COM interface.</fsummary>
      <desc>
	<p>
	  In COM, all interfaces are reference-counted. The release function
	  decrements the reference counter, and releases the interface (or object)
	  if it reaches zero. Note that it is important to release all objects
	  created, and interfaces acquired. Otherwise resource leaking will occur.
      </desc>
    </func>
    <func>
      <name>com_call(ComInterface, MethodOffs, Pars)</name>
      <fsummary>Call a COM method, using the V-table.</fsummary>
      <type>
	<v>MethodOffs = integer()</v>
	<v>Pars = list()</v>
      </type>
      <desc>
	<p>
	  This is the way to call a method in a COM interface. Beware that
	  the parameter types must match the types in the COM interface
	  function.
	<p>
	  Note that return values are handled with <c>out</c> parameters
	  when using <c>com_call/3</c>. (As opposed to <c>invoke/3</c>.
      </desc>
    </func>
  </funcs>
  <funcs>
    <func>
      <name>invoke(ComInterface, MethodID, Pars)</name>
      <name>invoke(ComInterface, MethodName, Pars)</name>
      <fsummary>Invoke a COM method, using the dispatch interface.</fsummary>
      <desc>
	<p>
	  There are two ways to call a method in a COM interface. A dual- or
	  dispatch-interface, has a method invoke, that is used to call methods.
	  This method is intended for interpreted languages. The invoke method
	  is safer than <c>com_call</c>, but also much slower.
	
      </desc>
    </func>
  </funcs>
  <funcs>
    <func>
      <name>property_get(ComInterface, MethodID)</name>
      <name>property_get(ComInterface, MethodID, [Parameters])</name>
      <name>property_get(ComInterface, MethodName)</name>
      <name>property_get(ComInterface, MethodName, [Parameters])</name>
      <fsummary>Get a COM property, using the dispatch interface.</fsummary>
      <desc>
	<p>
	  To get a property value through the dispatch-interface, this function
	  is used.
      </desc>
    </func>
    <func>
      <name>property_put(ComInterface, MethodID, Value)</name>
      <name>property_put(ComInterface, MethodID, [Parameters], Value)</name>
      <name>property_put(ComInterface, MethodName, Value)</name>
      <name>property_put(ComInterface, MethodName, [Parameters], Value)</name>
      <fsummary>Set a COM property, using the dispatch interface.</fsummary>
      <desc>
	<p>
	  To set a property value through the dispatch-interface, this function
	  is used.
      </desc>
    </func>
  </funcs>
  
<authors>
    <aname>Jakob Cederlund</aname>
    <email>jakob@erix.ericsson.se</email>
  </authors>
</erlref>
