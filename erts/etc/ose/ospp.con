/* --- Contributions ---
*  bsp.mk
*  debug.mk
*  kernel.mk
*/

/*****************************************************************************
*          /////////////                          ///////////////            *
*      /////////////////////                  ///////////////////////        *
*    ///////////////////////////           ////////////////////////////      *
*  ///////////////////////////////        ///////////////////////////////    *
* //////////////      /////////////      /////////////         ///////////   *
* ///////////             //////////     /////////               //////////  *
* /////////                 ////////    //////////               //////////  *
* ///////                    ////////   ////////////                         *
* //////                      ///////    /////////////                       *
* /////                       ////////    ////////////////////////           *
* /////                       ////////      /////////////////////////        *
* /////                       ////////       ////////////////////////////    *
* /////                       ////////          ///////////////////////////  *
* /////                       //#############                /////////////// *
* //////                     ///#############                  ///////////// *
* ///////                   ////####/                             ////////// *
* /////////               //////############///////                ///////// *
* //////////            ////////############////////              ////////// *
* /////////////     ////////////####     /////////////           /////////// *
*  //////////////////////////// #############//////////////////////////////  *
*   //////////////////////////  #############////////////////////////////    *
*      ///////////////////                  /////////////////////////        *
*          /////////////                        /////////////////            *
*                                                                            *
*                                                                            *
*                  MULTITASKING REALTIME OPERATING SYSTEM.                   *
*                                                                            *
*                       1999, Enea OSE Systems AB.                           *
*                                                                            *
******************************************************************************
*@(#) File: ospp.con		Id: 510/OSE34-1
*@(#) Revision: R1.7.0		Revision date: 990907
* 
*  This file contains configuration data for the OSE operating system.
* 
*  Syntax definition format:
* 
*  Comments are written in C syntax.
*  Data within angles (< >) are user supplied names or numbers.
*  Hexadecimal values must be prefixed with a "0x" (C style).
*  Vertical bar (|) represents a choice in the syntax definitions.
*  Default values are enclosed in brackets ([ ]).
*  Example: YES | [NO] means that either YES or NO can be selected,
*  and NO is default.
* 
*
* Table of contents
*
* 1 Kernel functionality
*
*   1.1  OSE debugger
*   1.2  Error checks
*   1.3  Memory model
*   1.4  Remote calls
*   1.5  Inherit preinstalled Board Support Packet
*
* 2 Memory usage
*
*   2.1  CPU type
*   2.2  System pool size
*   2.3  Signal buffer sizes
*   2.4  Stack sizes
*   2.5  Supervisor stack size
*   2.6  Tracebuffer size
*   2.7  Maximum number of processes
*   2.8  Max attached
*   2.9  User area
*   2.10 Kernel Start Stack Size
*
* 3 System timer
*
*   3.1  System timer
*   3.2  Internal timer
*
* 4 Handlers
*
*   4.1  System error handler
*   4.2  Start handler 1
*   4.3  Vector handler
*   4.4  Interrupt mask handler
*   4.5  Power on handler
*   4.6  Power off handler
*   4.7  Warm start handler
*   4.8  Start status handler
*   4.9  Create handler
*   4.10  Kill handler
*   4.11  Swap in handler
*   4.12 Swap out handler
*   4.13 Read timer handler
*   4.14 Clear timer handler
*   4.15 Set breakpoint handler
*   4.16 Clear breakpoint handler
*   4.17 Attach block handler
*   4.18 Select segment handler
*   4.19 Int create handler
*   4.20 Int kill handler
*   4.21 Memory move handler
*
* 5 Priorities
*
*   5.1  System daemon priority
*   5.2  Hunt daemon priority
*   5.3  zzmain priority
*   5.4  Ose LDM priority
*
* 6 Miscellaneous
*
*   6.1  System process
*   6.2  Breakpoint level
*   6.3  Vector address
*   6.4  Preserve vector
*/


/*
* 1	Kernel functionality
*
* 1.1	OSE debugger
*
* Set this field to YES if the OSE debugger (LDM) should be included in target.
*
* Syntax:	DEBUG(YES | [NO])
*/

DEBUG(NO)

/*
* 1.2	Error checks
*
* Set error check level.
*	0	No error checking.
*	1	Only error checks with small realtime impact is performed.
*	2	Full error checking.
*
* Syntax:	ERROR_CHECKS([0] | 1 | 2)
*/

ERROR_CHECKS(2)


/*
* 1.3	Memory model
*
* Select memory protection mode.
*	0	Intersegment copying between pools is not supported.
*	1	Intersegment copying between pools is supported.
*
* Syntax:	MEMORY_MODEL([0] | 1)
*/

MEMORY_MODEL(0)

/*
* 1.4	Remote calls
*
* Setting this entry to YES, enables the use of remote calls.
*
* Syntax:	REMOTE_CALLS(YES | [NO])
*/



/*
*  1.5	Inherit preinstalled Board Support Packet
* 
*  This option makes it possible to use a prommed OSE BSP in a running
*  system. The system inherits the bios and the device drivers present
*  in the BSP.
*  
*  Also these items are inherited from the the BSP:
*	+ Frequence feeding the INTERNAL_TIMER counter
*	+ PRESERVE_VECTOR exception vectors handled by the BSP
*	+ OSE kernel trap numbers for the M68K architecture
*	+ The BSP START_HANDLER1
*	+ The BSP START_OSE_HOOK2 
*  These items are inherited from the the BSP, but may be overriden by
*  configuration statements in this file AFTER the 
*  INHERIT_PREINSTALLED_BSP(YES) line:
* 	+ The BSP VECTOR_HANDLER
*	+ The BSP INT_MASK_HANDLER
*	+ The BSP INT_CREATE_HANDLER
*	+ The BSP INT_KILL_HANDLER
*
*  Syntax:       INHERIT_PREINSTALLED_BSP(YES | [NO])
*/

/*
* 2	Memory usage
*
* 2.1	CPU type (must always be present)
*
* Enter CPU type.
*
* Syntax:	CPU(<type>)
*
* Example:	CPU(603)
*/

CPU(750)

/*
* 2.2	System pool size (must always be present)
*
* Enter the number of bytes that should be reserved for the system pool.
*
* Syntax:	POOL_SIZE(<size>)
*/

/*POOL_SIZE(2048000) */
/*POOL_SIZE(4096000) */
/*POOL_SIZE(6144000) */
POOL_SIZE(8192000)
/*->POOL_SIZE(10240000) */
/*POOL_SIZE(12288000) */
/*POOL_SIZE(14336000) */
/*POOL_SIZE(16384000) */


/*
* 2.3	Signal buffer sizes
*
* Enter a list of the desired signal buffer sizes. The list must be sorted
* in increasing order and 8 sizes must always be selected.
*
* Syntax:
*	BUFFERSIZES(<siz1>,<siz2>,<siz3>,<siz4>,<siz5>,<siz6>,<siz7>,<siz8>)
*
*	Default: 31,63,127,255,511,1023,2047,65535
*/

/*BUFFERSIZES( 31, 63, 127, 255, 511, 1023, 2047, 65535 )*/
/*BUFFERSIZES( 31, 63, 127, 255, 1023, 2047, 16383, 65535 )*/
/*BUFFERSIZES( 63, 127, 255, 511, 1023, 4095, 65535, 1048575 )*/
/*BUFFERSIZES( 63, 127, 255, 511, 1023, 4095, 65535, 2097152 )*/  
  BUFFERSIZES( 63, 127, 255, 1023, 4095, 10240, 131072, 512000 )

/*
* 2.4	Stack sizes
*
* Enter a list of the desired stack sizes. The list must be sorted
* in increasing order and 8 sizes must always be selected.
*
* Syntax:
*	STACKSIZES(<siz1>,<siz2>,<siz3>,<siz4>,<siz5>,<siz6>,<siz7>,<siz8>)
*
*	Default: 256,512,1024,2048,4096,8192,16384,65536
*/

/*STACKSIZES(256,512,1024,2048,4096,8192,16384,262144) */
STACKSIZES( 511, 1023, 2047, 4095, 8191, 16383, 65535, 1048575 )


/*
* 2.5	Supervisor stack size
*
* This entry increases the size of supervisor stack for each process.
* Can be used for example if a handler needs a very large stack.
*
* Syntax:	SUPERV_SIZE(<size>)
*/
SUPERV_SIZE(512)


/*
* 2.6	Tracebuffer size
*
* Enter the number of bytes that should be reserved for the trace buffer.
*
* Syntax:	TRACEBUFF_SIZE(<size>)
*/



/*
* 2.7	Maximum number of processes
*
* Enter the maximum number of processes that can be present in the system.
*
* Syntax:	MAXPROCS(<number>)
*/

MAXPROCS(1024)

/*
* 2.8	Max attached
*
* Enter the maximum number of attachments that can be pending in the system.
*
* Syntax:	MAX_ATTACHED(<number>)
*/

MAX_ATTACHED(4096)

/*
* 2.9	User area
*
* Enter the number of bytes that should be reserved for each process.
* This area can be used by handlers.
*
* Syntax:	USER_AREA(<size>)
*/



/*
*  2.11	Kernel Start Stack Size
* 
*  The Kernel Start Stack is used in the early system start, before
*  the system pool is available. Any user-provided handlers of the 
*  following types use this stack:
*  POWER_ON_HANDLER
*  START_HANDLER1
*  WARM_START_HANDLER
* 
*  The default value is sufficient for normal use, but if large stack
*  usage is needed in these handlers, you may need to increase the
*  value. The value that you configure here is ADDED to the default.
* 
* 
*  Syntax:       START_STACK(<size_added>)
*/

/*
* 3	System timer
*
* 3.1	System timer
*
* Enter the time in milliseconds between each system tick.
* The time between each tick must be a power of 2.
* Select one of: [1],2,4,8,16,32,64
*
* Syntax:	SYSTEM_TIMER(<ms per system tick>)
*/

SYSTEM_TIMER(4)

/*
* 3.2	Internal timer
*
* If an internal timer is available on the CPU chip, it can be used as a
* system tick timer. If internal timer is selected, an interrupt process
* is created by the system which will handle the timer interrupt.
* The tick system call will run at lowest interrupt level (31).
*
* The <clock frequency> parameter is the frequency, given in kHz,
* of the internal timer.
* This may not be the same frequency as the CPU clock frequency.
*
* For 603/750 the decrementer timer (DEC) will be used.
* This timer has a clock frequency one fourth of bus clock rate
* (e.g., 16500 for a 66 MHz board).
*
* For 403 the Programmable Interval Timer (PIT) will be used.
* This timer has the same clock frequency as the CPU frequency
* (e.g., 33333 for a 33.333300 MHz board).
*
* For 860 the decrementer timer (DEC) will be used.
* Typical values:
* Motorola ADS board with 25 MHz MPC860: 1000
* Motorola MBX board with 25 MHz MPC860: 1598
* Motorola MBX board with 40 MHz MPC860: 2500
* EST SBC860 board with 25 MHz MPC860:   1598
*
* Syntax:	INTERNAL_TIMER(<clock frequency>)
*/

INTERNAL_TIMER(25000)


/*
* 4	Handlers
*
* 4.1	Error handler
*
* Enter the name of a user provided system error handler. If no error handler
* is present, the system will enter an infinite loop when an error occurs.
* Return nonzero if the error has been corrected.
*
* Syntax:	ERROR_HANDLER(<name>)
*
* Example:	ERROR_HANDLER(errh)
*
*		Prototype: OSADDRESS errh(OSBOOLEAN user_called,
*					  OSERRCODE ecode,
*					  OSERRCODE extra);
*/

ERROR_HANDLER(err_hnd)


/*
* 4.2	Start handler1
*
* These routines are run before the OS has been initialized. Therefore no
* system calls can be used.
*
* Syntax:	START_HANDLER1(<name>)
*
* Example:	START_HANDLER1(init_hw1)
*		START_HANDLER1(starth1)
*
*		Prototype: void init_hw1(void);
*/

START_HANDLER1(bspStartHandler1)

/*
* 4.3	Vector handler
*
* The vector handler is called every time an external interrupt occurs.
* This handler should examine all interrupt sources in the system and
* return the vector number of the highest priority pending interrupt.
* After the vector handler has executed, the interrupt mask handler
* is invoked to block lower priority interrupt processes while the
* current interrupt process is executing.
*
* For the 403 this handler could also acknowledge the interrupt by writing
* a "1" to the corresponding bit in the interrupt status register (EXISR).
* This is only required for edge triggered interrupt inputs.
*
* Syntax:	VECTOR_HANDLER(<name>)
*
* Example:	VECTOR_HANDLER(vector_handler)
*
*		Prototype: OSVECTOR vector_handler(void)
*/

VECTOR_HANDLER(bspVectorHandler)

/*
* 4.4	Interrupt mask handler
*
* The purpose of this handler is to mask all interrupt sources on the supplied
* level and below this level. This is required to allow nested interrupts on
* the PowerPC architecture.
* The supplied level has a value between 0 and 32.
* 0 means that all interrupt sources in use should be masked.
* 32 means that all interrupt sources in use should be enabled.
*
* Syntax:	INT_MASK_HANDLER(<name>)
*
* Example:	INT_MASK_HANDLER(int_mask_handler)
*
*		Prototype: void int_mask_handler(OSPRIORITY level)
*/

INT_MASK_HANDLER(bspIntMaskHandler)

/*
* 4.5	Power on handler
*
* The power on handler decides if the system has been shut down properly by
* the power off handler. Return nonzero if the system is intact and can
* resume executing.
*
* Syntax:	POWER_ON_HANDLER(<name>)
*
* Example:	POWER_ON_HANDLER(power_on)
*
*		Prototype: OSBOOLEAN power_on(void);
*/



/*
* 4.6	Power off handler
*
* This handler shuts down the system. Does not return.
*
* Syntax:	POWER_OFF_HANDLER(<name>)
*
* Example:	POWER_OFF_HANDLER(power_off)
*
*		Prototype: void power_off(void);
*/



/*
* 4.7	Warm start handler
*
* After each system restart, the debugger tries to recover its previous state.
* If possible the old state will be used, otherwise a cold start will be
* performed. This handler can be used to force a cold start. Return non zero
* to allow a warm start.
*
* Syntax:	WARM_START_HANDLER(<name>)
*
* Example:	WARM_START_HANDLER(warm_starth)
*
*		Prototype: OSBOOLEAN warm_starth(void);
*/



/*
* 4.8	Start status handler
*
* This handler is used by the system debugger. It returns zero if application
* processes should be allowed to run after system cold start. Returns nonzero
* if application processes should be immediately intercepted when they are
* created, allowing the system debugger to examine the system before it runs.
*
* Syntax:	START_STATUS_HANDLER(<name>)
*
* Example:	START_STATUS_HANDLER(start_status)
*
*		Prototype: OSBOOLEAN start_status(void);
*/



/*
* 4.9	Create handler
*
* These handlers are run every time a process is created. The user area
* parameter is valid only if the USER_AREA entry has been configured.
*
* Syntax:	CREATE_HANDLER(<name>)
*
* Example:	CREATE_HANDLER(createh)
*		CREATE_HANDLER(createh2)
*
*		Prototype: void createh(void *user_area,
*					PROCESS pid,
*					PROCESS parentpid);
*/



/*
* 4.10	Kill handler
*
* These handlers are run every time a process is killed. The user area
* parameter is valid only if the USER_AREA entry has been configured.
*
* Syntax:	KILL_HANDLER(<name>)
*
* Example:	KILL_HANDLER(killh)
*		KILL_HANDLER(another_killh)
*
*		Prototype: void killh(void *user_area, PROCESS pid);
*/



/*
* 4.11	Swap in handler
*
* These handlers are run every time a process is swapped in. The user area
* parameter is valid only if the USER_AREA entry has been configured.
*
* Syntax:	SWAP_IN_HANDLER(<name>)
*
* Example:	SWAP_IN_HANDLER(swap_inh)
*		SWAP_IN_HANDLER(next_swap_inh)
*
*		Prototype: void swap_inh(void *user_area);
*/



/*
* 4.12	Swap out handler
*
* These handlers are run every time a process is swapped out. The user area
* parameter is valid only if the USER_AREA entry has been configured.
*
* Syntax:	SWAP_OUT_HANDLER(<name>)
*
* Example:	SWAP_OUT_HANDLER(swap_outh)
*		SWAP_OUT_HANDLER(swap_outh2)
*
*		Prototype: void swap_outh(void *user_area);
*/



/*
* 4.13	Read timer handler
*
* This handler returns the time, in microseconds, elapsed since last call to
* the clear timer handler.
*
* Syntax:	READ_TIMER_HANDLER(<name>)
*
* Example:	READ_TIMER_HANDLER(read_timer)
*/



/*
* 4.14	Clear timer handler
*
* This handler clears the system timer.
*
* Syntax:	CLEAR_TIMER_HANDLER(<name>)
*
* Example:	CLEAR_TIMER_HANDLER(clear_timer)
*/



/*
* 4.15	Set breakpoint handler
*
* This handler is called after a breakpoint has been set by the set_bp system
* call.
*
* Syntax:	SET_BP_HANDLER(<name>)
*
* Example:	SET_BP_HANDLER(set_bph)
*
*		Prototype: void set_bph(OSADDRESS addr,
*					OSADDRESS old_data,
*					OSADDRESS new_data);
*/


/*
* 4.16	Clear breakpoint handler
*
* This handler is called after a breakpoint has been cleared by the clear_bp
* system call.
*
* Syntax:	CLEAR_BP_HANDLER(<name>)
*
* Example:	CLEAR_BP_HANDLER(cl_bph)
*
*		Prototype: void cl_bph(OSADDRESS addr,
*				       OSADDRESS old_data,
*				       OSADDRESS new_data);
*/



/*
* 4.17	Attach block handler
*
* This handler is called when a new block has been created.
*
* Syntax:	ATTACH_BLOCK_HANDLER(<name>)
*
* Example:	ATTACH_BLOCK_HANDLER(attach_block)
*
*		Prototype: void attach_block(PROCESS bid, OSSEGMENT segnum);
*/



/*
* 4.18	Select segment handler
*
* This handler is called when the OSE dispatcher needs to select a new
* address space.
*
* Syntax:	SELECT_SEGMENT_HANDLER(<name>)
*
* Example:	SELECT_SEGMENT_HANDLER(select_segment)
*
*		Prototype: void select_segment(OSSEGMENT segnum);
*/



/*
* 4.19	Interrupt create handler
*
* This handler is called when a new interrupt has got it's vector
* installed. At this point, it will be acceptable to start using that
* particular interrupt. Please don't confuse this with the regular
* create handler.
*
* Only one handler is allowed.
*
* Syntax:	INT_CREATE_HANDLER(<name>)
*
* Example:	INT_CREATE_HANDLER(int_create_handler)
*
*		Prototype: void int_create_handler(OSVECTOR vecno,
*						   OSPRIORITY prio)
*/

INT_CREATE_HANDLER(bspIntCreateHandler)


/*
* 4.20	Interrupt kill handler
*
* This is the opposite of the interrupt create handler. It is called
* just before the interrupt vector is removed, and at that time it will
* no longer be acceptable to allow interrupts from that source.
*
* Only one handler is allowed.
*
* Syntax:	INT_KILL_HANDLER(<name>)
*
* Example:	INT_KILL_HANDLER(int_kill_handler)
*
*		Prototype: void int_kill_handler(OSVECTOR vecno,
*						 OSPRIORITY prio)
*/

INT_KILL_HANDLER(bspIntKillHandler)


/*
* 4.21	Memory move handler
*
* This handler is called when the kernel requires a block of memory to be
* copied from one memory segment to another.
* Return zero for success.
*
* Only one handler is allowed.
* 
* Syntax:	MEM_MOVE_HANDLER(<name>)
*
* Example:	MEM_MOVE_HANDLER(mem_move_handler)
*
*		Prototype:
*		OSBOOLEAN mem_move_handler(OSSEGMENT src_segment,
*					   OSADDRESS src_begin,
*					   OSADDRESS size,
*					   OSSEGMENT dest_segment,
*					   OSADDRESS dest_begin);
*/



/*
* 5 Priorities
*
* This section of the configuration gives you the possibility to
* configure the priority of the different system processes created
* by the kernel at start-up. Refer to the OSE users guide for a more
* detailed description of the processes.
* The value in brackets '[x]' is the default priority for that
* process if no configuration is entered. This can also be seen as
* a recommended value for that process.
*
*   5.1  System daemon priority
*
* The system deamon is used when creating and killing processes and blocks.
*
* Syntax:	OSESYSD_PRIO(<prio>)	[20]
*/



/*
*   5.2  Hunt daemon priority
*
* The Hunt deamon is also used when new processes are created and when there
* is a HUNT system call.
*
* Syntax:	HUNTD_PRIO(<prio>)	[10]
*/



/*
*   5.3  zzmain priority
*
* The zzmain process is the process that starts all static processes.
*
* Syntax:	ZZMAIN_PRIO(<prio>)	[16]
*/



/*
*   5.4  Ose LDM priority
*
* The LDM is the Local Debug Module, which is used together with
* the System Debugger (DDS).
*
* Syntax:	OSELDM_PRIO(<prio>)	[1]
*/



/*
* 6	Miscellaneous
*
* 6.1	System process
*
* List processes that should never be stopped by the OSE debugger.
* Useful for processes that are maintaining communication with the host.
*
* Syntax:	SYSTEM_PROCESS(<name>)
*/

SYSTEM_PROCESS( ose_* )

/*
* 6.2	Breakpoint level
*
* Enter the interrupt level on which the breakpoint handling will be run.
* Level must be in the interval 0-31. 0 is the highest priority.
* Default: 31
*
* Syntax:	BP_LEVEL(<level>)
*/



/*
* 6.3	Vector address
*
* This entry sets the base address of the exception table.
* If this entry is left empty, vector code will be installed on the
* current base address.
*
* Syntax:	VECTOR_ADDRESS(<address>)
*/



/*
* 6.4	Preserve vector
*
* This entry is used to preserve vectors from being overwritten by the kernel.
* When using a target debugger monitor, some vectors are required by the
* monitor and must be preserved by the kernel.
* If this entry is left empty, all vectors will be overwritten by the kernel.
* Insert an entry for every vector that should be preserved.
* The count parameter is used to preserve continues vectors.
*
* Syntax:	PRESERVE_VECTOR(<vector offset>,<count>)
*
* Example:	Preserve vectors at offset 0x700 and 0xd00.
*		PRESERVE_VECTOR(0x700,1)
*		PRESERVE_VECTOR(0xd00,1)
*
*		Preserve all vectors (0x100 - 0x2000).
*		PRESERVE_VECTOR(0x100,31)
*/

PRESERVE_VECTOR(0x700,1)
PRESERVE_VECTOR(0xd00,1)

