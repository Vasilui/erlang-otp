dnl Process this file with autoconf to produce a configure script. -*-m4-*-
dnl
dnl
dnl The string "FIXME convbreak" means that there is a break of
dnl autoconf convention that should be cleaned up.
dnl
dnl
AC_PREREQ(2.13)
AC_INIT(vsn.mk)

if test "x$no_recursion" != "xyes"; then
    # We do not want to use a common cache!
    cache_file=/dev/null
fi

dnl How to set srcdir absolute is taken from the GNU Emacs distribution
#### Make srcdir absolute, if it isn't already.  It's important to
#### avoid running the path through pwd unnecessary, since pwd can
#### give you automounter prefixes, which can go away.
case "${srcdir}" in
  /* ) ;;
  . )
    ## We may be able to use the $PWD environment variable to make this
    ## absolute.  But sometimes PWD is inaccurate.
    ## Make sure CDPATH doesn't affect cd (in case PWD is relative).
    CDPATH=
    if test "${PWD}" != "" && test "`(cd ${PWD} ; sh -c pwd)`" = "`pwd`"  ;
    then
      srcdir="$PWD"
    else
      srcdir="`(cd ${srcdir}; pwd)`"
    fi
  ;;
  *  ) srcdir="`(cd ${srcdir}; pwd)`" ;;
esac

## Now, make sure that ERL_TOP is set and is the same as srcdir
##
if test -z "$ERL_TOP" || test ! -d $ERL_TOP ; then
  AC_MSG_ERROR(You need to set the environment variable ERL_TOP!)
fi
if test x"${ERL_TOP}/erts" != x"$srcdir"; then
  AC_MSG_ERROR([You need to run configure with argument --srcdir=${ERL_TOP}/erts])
fi
erl_top=${ERL_TOP}

# echo XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
# echo X
# echo "X srcdir  = $srcdir"
# echo "X ERL_TOP = $ERL_TOP"
# echo X
# echo XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

AC_CONFIG_AUX_DIRS($srcdir/autoconf)

dnl ----------------------------------------------------------------------
dnl Figure out what system we are running on.
dnl ----------------------------------------------------------------------

#
# To configure for free source run ./configure --host=free_source
#
dnl
dnl AC_CANONICAL_HOST does not like free_source as a host specification,
dnl so we make a little special case.
dnl
if test "X$host" != "Xfree_source" -a "X$host" != "Xwin32"; then
    AC_CANONICAL_HOST
else
    host_os=$host
fi
AC_ISC_POSIX

AC_CONFIG_HEADER($host/config.h:config.h.in include/internal/$host/ethread_header_config.h:include/internal/ethread_header_config.h.in include/$host/erl_int_sizes_config.h:include/erl_int_sizes_config.h.in)
dnl ----------------------------------------------------------------------
dnl Optional features.
dnl ----------------------------------------------------------------------
enable_child_waiter_thread=no
ENABLE_ALLOC_TYPE_VARS=
AC_SUBST(ENABLE_ALLOC_TYPE_VARS)

dnl Defined in libraries/megaco/configure.in but we need it here
dnl also in order to show it to the "top user"

AC_ARG_ENABLE(threads,
[  --enable-threads        enable async thread support
  --disable-threads       disable async thread support],
[ case "$enableval" in
    no) enable_threads=no ;;
    *)  enable_threads=yes ;;
  esac ], enable_threads=unknown)

AC_ARG_ENABLE(smp-support,
[  --enable-smp-support    enable smp support
  --disable-smp-support   disable smp support],
[ case "$enableval" in
    no) enable_smp_support=no ;;
    *)  enable_smp_support=yes ;;
  esac ], enable_smp_support=unknown)

AC_ARG_ENABLE(lock-checking,
[  --enable-lock-checking  enable lock checking],
[ case "$enableval" in
    no) enable_lock_check=no ;;
    *)  enable_lock_check=yes ;;
  esac
],
  enable_lock_check=no)

AC_ARG_ENABLE(kernel-poll,
[  --enable-kernel-poll    enable kernel poll support])

AC_ARG_ENABLE(hipe,
[  --disable-hipe          disable hipe support])

AC_ARG_ENABLE(tsp,
[  --enable-tsp            compile tsp app])

AC_ARG_ENABLE(elib-malloc,
[  --enable-elib-malloc    use elib_malloc instead of normal malloc])

AC_ARG_ENABLE(fixalloc,
[  --disable-fixalloc      disable the use of fix_alloc])
if test x${enable_fixalloc} = xno ; then
  AC_DEFINE(NO_FIX_ALLOC)
fi

AC_SUBST(PERFCTR_PATH)
AC_ARG_WITH(perfctr,
[  --with-perfctr=PATH     specify location of perfctr include and lib
  --without-perfctr       don't use perfctr (default)])

if test "x$with_perfctr" = "xno" -o "x$with_perfctr" = "x" ; then
    PERFCTR_PATH=
else
    if test ! -f "$with_perfctr/usr.lib/libperfctr.a" ; then
	AC_MSG_ERROR(Invalid path to option --with-perfctr=PATH)
    fi
    PERFCTR_PATH="$with_perfctr"
    AC_DEFINE(USE_PERFCTR)
fi

AC_ARG_ENABLE(megaco_flex_scanner_lineno,
[  --disable-megaco-flex-scanner-lineno disable megaco flex scanner lineno])

dnl Magic test for clearcase.
OTP_RELEASE=
if test "${ERLANG_COMMERCIAL_BUILD}" != ""; then
	OTP_EXTRA_FLAGS=-DOTP_RELEASE
	OTP_RELEASE=yes
else
	OTP_EXTRA_FLAGS=
fi
AC_SUBST(OTP_RELEASE)

dnl ----------------------------------------------------------------------
dnl Checks for programs.
dnl ----------------------------------------------------------------------

AC_PROG_CC

dnl ---------------------------------------------------------------------
dnl Special windows stuff regarding CFLAGS and details in the environment...
dnl ---------------------------------------------------------------------

dnl NOTE: CPPFLAGS will be included in CFLAGS at the end
case $host_os in
    linux*) CPPFLAGS="$CPPFLAGS -D_GNU_SOURCE";; 
    *) ;;
esac

MIXED_CYGWIN=no

AC_MSG_CHECKING(for mixed cygwin and native VC++ environment)
if test "X$CC" = "Xcc.sh" -a "X$host" = "Xwin32" -a "x$GCC" != x"yes"; then
	if test -x /usr/bin/cygpath; then
		CFLAGS="-O2"
		MIXED_CYGWIN=yes
		AC_MSG_RESULT([yes])
		MIXED_CYGWIN_VC=yes
	else
		AC_MSG_RESULT([undeterminable])
		AC_MSG_ERROR(Seems to be mixed windows but not with cygwin, cannot handle this!)
	fi
else
	AC_MSG_RESULT([no])
	MIXED_CYGWIN_VC=no
fi
AC_SUBST(MIXED_CYGWIN_VC)

AC_MSG_CHECKING(for mixed cygwin and native MinGW environment)
if test "X$CC" = "Xcc.sh" -a "X$host" = "Xwin32" -a "x$GCC" = x"yes"; then
	if test -x /usr/bin/cygpath; then
		CFLAGS="-O2"
		MIXED_CYGWIN=yes
		AC_MSG_RESULT([yes])
		MIXED_CYGWIN_MINGW=yes
	else
		AC_MSG_RESULT([undeterminable])
		AC_MSG_ERROR(Seems to be mixed windows but not with cygwin, cannot handle this!)
	fi
else
	AC_MSG_RESULT([no])
	MIXED_CYGWIN_MINGW=no
fi
AC_SUBST(MIXED_CYGWIN_MINGW)

AC_MSG_CHECKING(if we mix cygwin with any native compiler)
if test "X$MIXED_CYGWIN" = "Xyes" ; then
	AC_MSG_RESULT([yes])	
else
	AC_MSG_RESULT([no])
fi

AC_SUBST(MIXED_CYGWIN)
	
dnl
dnl Flags to the C compiler
dnl
dnl Make sure we find config.h
dnl

extra_flags="-I${ERL_TOP}/erts/$host $OTP_EXTRA_FLAGS"
CFLAGS="$CFLAGS $extra_flags"
DEBUG_CFLAGS="-g $CPPFLAGS $extra_flags"
DEBUG_FLAGS=-g

CFLAG_RUNTIME_LIBRARY_PATH="-Wl,-R"
case $host_os in
  darwin*)
	CFLAG_RUNTIME_LIBRARY_PATH=
	CFLAGS="$CFLAGS -no-cpp-precomp"
	;;
  win32)
	CFLAG_RUNTIME_LIBRARY_PATH=
	;;
  osf*)
	CFLAG_RUNTIME_LIBRARY_PATH="-Wl,-rpath,"
	;;
  *)
	;;
esac


dnl
dnl Use the getconf utility if it exists
dnl to find large file support flags.
dnl
if type getconf >/dev/null 2>&1; then
	CFLAGS="$CFLAGS `getconf LFS_CFLAGS 2>/dev/null`"
	DEBUG_CFLAGS="$DEBUG_CFLAGS `getconf LFS_CFLAGS 2>/dev/null`"
	LDFLAGS="$LDFLAGS `getconf LFS_LDLAGS 2>/dev/null`"
	LIBS="$LIBS `getconf LFS_LIBS 2>/dev/null`"
fi

if test "x$GCC" = xyes; then
  # until the emulator can handle this, I suggest we turn it off!
  #WFLAGS="-Wall -Wshadow -Wcast-qual -Wmissing-declarations"
  WFLAGS="-Wall -Wstrict-prototypes -Wmissing-prototypes"
  #WFLAGS=""
else
  WFLAGS=""
fi
dnl DEBUG_FLAGS is obsolete (I hope)
AC_SUBST(DEBUG_FLAGS)
AC_SUBST(DEBUG_CFLAGS)
AC_SUBST(WFLAGS)
AC_SUBST(CFLAG_RUNTIME_LIBRARY_PATH)

dnl
dnl Figure out operating system and cpu architecture
dnl
OPSYS=noopsys
case $host_os in
win32) OPSYS=win32;;
*) ;;
esac
case `uname -s` in
SunOS)	case `uname -r` in
	5.*)	OPSYS=sol2;;
	esac;;
Linux)	OPSYS=linux;;
Darwin)	OPSYS=darwin;;
esac
ARCH=noarch
case `uname -m` in
sun4u)	ARCH=ultrasparc;;
sparc64)	ARCH=ultrasparc;;
sun4v)	ARCH=ultrasparc;;
i86pc)	ARCH=x86;;
i386)	ARCH=x86;;
i486)	ARCH=x86;;
i586)	ARCH=x86;;
i686)	ARCH=x86;;
x86_64) ARCH=amd64;;
ppc)	ARCH=ppc;;
ppc64)	ARCH=ppc64;;
"Power Macintosh")	ARCH=ppc;;
armv5b)	ARCH=arm;;
esac
AC_SUBST(OPSYS)
AC_SUBST(ARCH)

dnl some tests below will call this if we haven't already - and autoconf
dnl can't handle those tests being done conditionally at runtime
AC_PROG_CPP

AC_PROG_RANLIB

AC_PROG_YACC
LM_PROG_PERL5
if test "$ac_cv_path_PERL" = false; then
  AC_MSG_ERROR([Perl version 5 is required to build the emulator!])
fi
AC_PROG_LN_S


AC_CHECK_PROG(AR, ar, ar, false)
if test "$ac_cv_prog_AR" = false; then
  AC_MSG_ERROR([No 'ar' command found in PATH])
fi

_search_path=/bin:/usr/bin:/usr/local/bin:$PATH

AC_PATH_PROG(RM, rm, false, $_search_path)
if test "$ac_cv_path_RM" = false; then
  AC_MSG_ERROR([No 'rm' command found])
fi

AC_PATH_PROG(MKDIR, mkdir, false, $_search_path)
if test "$ac_cv_path_MKDIR" = false; then
  AC_MSG_ERROR([No 'mkdir' command found])
fi

_search_path=

dnl
dnl We can live with Solaris /usr/ucb/install
dnl
case $host in
  *-*-solaris*|free_source)
    if test -x /usr/ucb/install; then
      INSTALL="/usr/ucb/install -c"
    fi
    ;;
  *)
    ;;
esac
AC_PROG_INSTALL
LM_PROG_INSTALL_DIR

case $host_os in
	darwin*)
		dnl Need to preserve modification time on archives;
		dnl otherwise, ranlib has to be run on archives
		dnl again after installation.
		INSTALL_DATA="$INSTALL_DATA -p";;
	*)
		;;
esac

dnl ----------------------------------------------------------------------
dnl Misc. things (some of them should go away)
dnl ----------------------------------------------------------------------

dnl
dnl An attempt to allow cross compiling. This is not the right way,
dnl nor does it work currently. Some makefiles still needs these
dnl variables, so we leave them in for now.
dnl
HCC='$(CC)'         AC_SUBST(HCC)
HCFLAGS=""          AC_SUBST(HCFLAGS)
HCFLAGS="$HCFLAGS -I${ERL_TOP}/erts/$host"
vxworks_reclaim=""  AC_SUBST(vxworks_reclaim)
LD='$(CC)'          AC_SUBST(LD)


dnl Check for cygwin and object/exe files extension
AC_CYGWIN
AC_EXEEXT
AC_OBJEXT

dnl This is the os flavour, should be unix, vxworks or win32
if test "X$host" = "Xwin32"; then
	ERLANG_OSTYPE=win32
else
	ERLANG_OSTYPE=unix         
fi

AC_SUBST(ERLANG_OSTYPE)

dnl Which sysv4 would this be, and what is it for???
dnl XXX: replace with feature tests.
case $host_os in
  sysv4*)
    AC_DEFINE(SOCKOPT_CONNECT_STAT)
    AC_DEFINE(NO_PRAGMA_WEAK)
    LIBS="$LIBS -lgen -lc -L /usr/ucblib -lucb"
    ;;
esac

# Check how to export functions from the emulator executable, needed
# when dynamically loaded drivers are loaded (so that they can find
# emulator functions).
# OS'es with ELF executables using the GNU linker (Linux and recent *BSD,
# in rare cases Solaris) typically need '-Wl,-export-dynamic' (i.e. pass
# -export-dynamic to the linker - also known as -rdynamic and some other
# variants); some sysVr4 system(s) instead need(s) '-Wl,-Bexport'.
# AIX 4.x (perhaps only for x>=2) wants -Wl,-bexpall,-brtl and doesn't
# reliably return an error for others, thus we separate it out.
# Otherwise we assume that if the linker accepts the flag, it is needed.
AC_MSG_CHECKING(for extra flags needed to export symbols)
DEXPORT=""
case $host_os in
	aix4*)
		DEXPORT=-Wl,-bexpall,-brtl
	;;
	bsdi*)
    		DEXPORT="-rdynamic " 
    	;;
	win32)
    		DEXPORT="" 
    	;;
	*)
		save_ldflags="$LDFLAGS"
		LDFLAGS=-Wl,-export-dynamic
		AC_TRY_LINK(,,[DEXPORT=-Wl,-export-dynamic], [
			LDFLAGS=-Wl,-Bexport
			AC_TRY_LINK(,,[DEXPORT=-Wl,-Bexport],
				AC_MSG_RESULT(none))])
		LDFLAGS="$save_ldflags"
	;;
esac
AC_SUBST(DEXPORT)
case "x$DEXPORT" in
	"x")
		AC_MSG_RESULT([none]);;
	*)
		AC_MSG_RESULT([$DEXPORT]);;
esac

# Check for Solaris/ultrasparc /dev/perfmon interface
# (also needs gcc specific asm instructions)
case "${host}:${GCC}" in
  sparc-*-solaris*:yes)
    AC_DEFINE(HAVE_SOLARIS_SPARC_PERFMON)
    ;;
  *)
    ;;
esac


dnl ----------------------------------------------------------------------
dnl Checks for libraries.
dnl ----------------------------------------------------------------------

AC_CHECK_LIB(m, sin)
AC_CHECK_LIB(dl, dlopen)
AC_CHECK_LIB(inet, main)

dnl Try to find a thread library.
dnl
dnl ETHR_LIB_NAME, ETHR_LIBS, ETHR_X_LIBS, ETHR_THR_LIB_BASE and ETHR_DEFS
dnl are set by LM_FIND_ETHR_LIB
LM_FIND_ETHR_LIB

if test "X$ETHR_LIB_NAME" = "X"; then
    found_threads=no
else
    found_threads=yes
fi


AC_CHECK_SIZEOF(void *, 4) # Needed for smp check below
ERTS_BUILD_SMP_EMU=$enable_smp_support
AC_MSG_CHECKING(whether an emulator with smp support should be built)
case $ERTS_BUILD_SMP_EMU in
    yes)
	AC_MSG_RESULT(yes; enabled by user)
	;;
    no)
	AC_MSG_RESULT(no; disabled by user)
	;;
    unknown)
	AC_TRY_COMPILE([],[
			#if __GNUC__ >= 3 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 95)
			;
			#else
			#error old or no gcc
			#endif
			],
			gcc_smp=okgcc,
			gcc_smp=oldornogcc)
	ERTS_BUILD_SMP_EMU=yes
	case "$enable_threads-$gcc_smp-$found_threads-$ARCH-$OPSYS-$ac_cv_sizeof_void_p" in

	    no-*)
		AC_MSG_RESULT(no; threads disabled by user)
		ERTS_BUILD_SMP_EMU=no
		;;

	    *-okgcc-yes-ultrasparc-sol2-4|*-okgcc-yes-ppc-darwin-4|*-okgcc-yes-x86-darwin-4)
		case $host_os in
		    solaris2.[[0-7]]|solaris2.[[0-7]].*)
			ERTS_BUILD_SMP_EMU=no;;
		    darwin[[0-7]]|darwin[[0-7]].*)
			ERTS_BUILD_SMP_EMU=no;;
		    *)
			;;
		esac
		AC_MSG_RESULT($ERTS_BUILD_SMP_EMU; default on this platform)
		;;

	    *-okgcc-yes-x86-linux-4|*-okgcc-yes-amd64-linux-4|*-okgcc-yes-amd64-linux-8|*-okgcc-yes-ppc-linux-4)
		if test "x$ETHR_THR_LIB_BASE_NAME" != "xnptl"; then
		    ERTS_BUILD_SMP_EMU=no
		else
		    linux_kernel_vsn_=`uname -r` # FIXME: for cross compilation.

		    # FIXME: Test for actual problems instead of kernel versions.
		    case $linux_kernel_vsn_ in
			[[0-1]].*|2.[[0-5]]|2.[[0-5]].*)
			    ERTS_BUILD_SMP_EMU=no;;
			*) ;;
		    esac
		fi
		AC_MSG_RESULT($ERTS_BUILD_SMP_EMU; default on this platform)
		;;

	    *-win32-*)
		AC_MSG_RESULT(no; default on this platform)
		ERTS_BUILD_SMP_EMU=no
		;;

	    *-oldornogcc-*)
		AC_MSG_RESULT(no; old gcc or no gcc found)
		ERTS_BUILD_SMP_EMU=no
		;;

	    *)
		AC_MSG_RESULT(no; default on this platform)
		ERTS_BUILD_SMP_EMU=no
		;;
	esac
	;;
esac

if test $ERTS_BUILD_SMP_EMU = yes; then

	if test $found_threads = no; then
	    AC_MSG_ERROR([cannot build smp enabled emulator since no thread library was found])
	fi

	case "$ARCH-$ac_cv_sizeof_void_p" in
	    x86-4|amd64-4|amd64-8|ppc-4|ultrasparc-4)
		;;
	    *)
		AC_MSG_ERROR([cannot build smp enabled emulator since hardware platform ($ARCH wordsize=$ac_cv_sizeof_void_p) is not supported]) ;;
	esac

	case $host_os in
	    win32)
		dnl * _WIN32_WINNT >= 0x0400 is needed for
		dnl   TryEnterCriticalSection
		dnl * _WIN32_WINNT >= 0x0403 is needed for
		dnl   InitializeCriticalSectionAndSpinCount
		AC_DEFINE(_WIN32_WINNT, 0x0403, \
[Define NT version if you want to turn on some NT features])
		AC_MSG_ERROR([smp enabled emulator not supported for windows yet])
		;;
	    linux*)
		
		if test "x$ETHR_THR_LIB_BASE_NAME" != "xnptl"; then
		    # Child waiter thread cannot be enabled
		    AC_MSG_ERROR([smp enabled emulator not supported on linux systems without the Native POSIX Thread Library (not found)])
		fi

		linux_kernel_vsn_=`uname -r` # FIXME: for cross compilation.

		# FIXME: Test for actual problems instead of kernel versions.
		case $linux_kernel_vsn_ in
		    [[0-1]].*|2.[[0-3]]|2.[[0-3]].*)
			# Child waiter thread cannot be enabled.
			AC_MSG_ERROR([smp enabled emulator not supported for linux kernels < 2.4])
			;;
		    *)
			;;
		esac
		;;
	    *)
		;;
	esac

	AC_DEFINE(ETHR_EXTENDED_LIB, 1, \
[Define if you want to enable extended functionality in the ethread library])
	AC_DEFINE(ERTS_HAVE_SMP_EMU, 1, [Define if the smp emulator is built])
	enable_threads=force
fi

AC_SUBST(ERTS_BUILD_SMP_EMU)


#
# Figure out if the emulator should use threads. The default is set above
# in the enable_threads variable. It can have the following values:
#
#   no      single-threaded emulator requested
#   yes     multi-threaded emulator requested
#   force   multi-threaded emulator required
#
# EMU_THR_LIB_NAME, EMU_THR_LIBS, EMU_THR_X_LIBS, and EMU_THR_DEFS is
# used by the emulator, and can (but should not) be used by applications
# that only require thread support when the emulator has thread support.
# Other applications should use ETHR_LIB_NAME, ETHR_LIBS, ETHR_X_LIBS,
# and ETHR_DEFS.
#
AC_MSG_CHECKING(whether the emulator should use threads)

EMU_THR_LIB_NAME=
EMU_THR_X_LIBS=
EMU_THR_LIBS=
EMU_THR_DEFS=
emu_threads=no

case "$enable_threads"-"$host_os" in
	*-win32)
		# The windows erlang emulator can never run without threads.
		# It has to be enabled or the emulator will crash. Until that
		# is fixed we force threads on win32.
		enable_threads=force ;;
	yes-osf*)
		# The emulator hang when threads are enabled on osf
		AC_MSG_ERROR(unresolved problems exist with threads on this platform) ;;
	*) ;;
esac

case "$enable_threads"-"$found_threads" in
    force-yes)
	emu_threads=yes
	AC_MSG_RESULT(yes; thread support required and therefore forced) ;;
    yes-yes)
	emu_threads=yes
	AC_MSG_RESULT(yes; enabled by user) ;;
    unknown-yes)
	case $host_os in
	    solaris*|linux*|darwin*|win32)
		emu_threads=yes
		AC_MSG_RESULT(yes; default on this platform)
		;;
	    *)
		AC_MSG_RESULT(no; default on this platform)
		;;
	esac
	;;
    no-yes)
	AC_MSG_RESULT(no; thread support found but disabled by user) ;;
    unknown-no|no-no)
	AC_MSG_RESULT(no) ;;
    force-no)
	AC_MSG_ERROR(thread support required but not found) ;;
    yes-no)
	AC_MSG_ERROR(thread support enabled by user but not found) ;;
    *)
	AC_MSG_ERROR(internal error) ;;
esac

if test $emu_threads != yes; then
	enable_lock_check=no
else
	# Threads enabled for emulator
	EMU_THR_LIB_NAME=$ETHR_LIB_NAME
	EMU_THR_X_LIBS=$ETHR_X_LIBS
	EMU_THR_LIBS=$ETHR_LIBS
	EMU_THR_DEFS=$ETHR_DEFS
	ENABLE_ALLOC_TYPE_VARS="$ENABLE_ALLOC_TYPE_VARS threads"
	AC_MSG_CHECKING(whether lock checking should be enabled)
	AC_MSG_RESULT($enable_lock_check)
	if test "x$enable_lock_check" != "xno"; then
	    EMU_THR_DEFS="$EMU_THR_DEFS -DERTS_ENABLE_LOCK_CHECK"
	fi
	case $host_os in
	    solaris*)
		enable_child_waiter_thread=yes
		;;
	    linux*)
		AC_DEFINE(USE_RECURSIVE_MALLOC_MUTEX)
		# -D_GNU_SOURCE already defined in CFLAGS remove it
		# from EMU_THR_DEFS
		new_emu_thr_defs=
		for thr_def in $EMU_THR_DEFS; do
		    case $thr_def in
			-D_GNU_SOURCE*)
			    ;;
			*)
			    new_emu_thr_defs="$new_emu_thr_defs $thr_def"
			    ;;
		    esac
		done
		EMU_THR_DEFS=$new_emu_thr_defs
		;;
	    *)
		;;
	esac

	AC_MSG_CHECKING(whether child waiter thread should be enabled in the emulator without smp support)
	if test $enable_child_waiter_thread = yes; then
	    AC_DEFINE(ENABLE_CHILD_WAITER_THREAD)
	    AC_MSG_RESULT(yes)
	else
	    AC_MSG_RESULT(no)
	fi
fi

AC_SUBST(EMU_THR_LIB_NAME)
AC_SUBST(EMU_THR_X_LIBS)
AC_SUBST(EMU_THR_LIBS)
AC_SUBST(EMU_THR_DEFS)


if test "x$enable_lock_check" = "xno"; then
    EMU_LOCK_CHECKING=no
else
    EMU_LOCK_CHECKING=yes
fi

AC_SUBST(EMU_LOCK_CHECKING)


dnl THR_LIBS and THR_DEFS are only used by odbc
THR_LIBS=$ETHR_X_LIBS
THR_DEFS=$ETHR_DEFS

AC_SUBST(THR_LIBS)
AC_SUBST(THR_DEFS)

dnl ----------------------------------------------------------------------
dnl Try to figure out where to get the termcap functions from.
dnl We use tgetent(), tgetflag(), tgetnum(), tgetstr() and tputs()
dnl ----------------------------------------------------------------------

TERMCAP_LIB=

if test "X$host" != "Xwin32"; then
    # try these libs
    termcap_libs="ncurses curses termcap termlib"

    for termcap_lib in $termcap_libs; do
	AC_CHECK_LIB($termcap_lib, tgetent, TERMCAP_LIB="-l$termcap_lib")
	if test "x$TERMCAP_LIB" != "x"; then
	    break
	fi
    done

    if test "x$TERMCAP_LIB" = "x"; then
	AC_MSG_ERROR([No curses library functions found])
    fi
fi

AC_SUBST(TERMCAP_LIB)

dnl
dnl This test kindly borrowed from Tcl
dnl
#--------------------------------------------------------------------
#	Check for the existence of the -lsocket and -lnsl libraries.
#	The order here is important, so that they end up in the right
#	order in the command line generated by make.  Here are some
#	special considerations:
#	1. Use "connect" and "accept" to check for -lsocket, and
#	   "gethostbyname" to check for -lnsl.
#	2. Use each function name only once:  can't redo a check because
#	   autoconf caches the results of the last check and won't redo it.
#	3. Use -lnsl and -lsocket only if they supply procedures that
#	   aren't already present in the normal libraries.  This is because
#	   IRIX 5.2 has libraries, but they aren't needed and they're
#	   bogus:  they goof up name resolution if used.
#	4. On some SVR4 systems, can't use -lsocket without -lnsl too.
#	   To get around this problem, check for both libraries together
#	   if -lsocket doesn't work by itself.
#--------------------------------------------------------------------

erl_checkBoth=0
AC_CHECK_FUNC(connect, erl_checkSocket=0, erl_checkSocket=1)
if test "$erl_checkSocket" = 1; then
    AC_CHECK_LIB(socket, main, LIBS="$LIBS -lsocket", erl_checkBoth=1)
fi
if test "$erl_checkBoth" = 1; then
    tk_oldLibs=$LIBS
    LIBS="$LIBS -lsocket -lnsl"
    AC_CHECK_FUNC(accept, erl_checkNsl=0, [LIBS=$tk_oldLibs])
fi
AC_CHECK_FUNC(gethostbyname, , AC_CHECK_LIB(nsl, main, [LIBS="$LIBS -lnsl"]))
AC_CHECK_FUNC(gethostbyname_r,have_gethostbyname_r=yes)
if test "$have_gethostbyname_r" = yes; then
	# OK, so we have gethostbyname_r() - but do we know how to call it...?
	# (if not, HAVE_GETHOSTBYNAME_R will not be defined at all)
	case $host_os in
		solaris2*)
			AC_DEFINE(HAVE_GETHOSTBYNAME_R, GHBN_R_SOLARIS)
		;;
		aix4*)
			# AIX version also needs "struct hostent_data" defn
			AC_TRY_COMPILE([#include <netdb.h>],
				[struct hostent_data hd;],
				AC_DEFINE(HAVE_GETHOSTBYNAME_R, GHBN_R_AIX))
		;;
		*)
			AC_EGREP_CPP(yes,[#include <stdio.h>
			  #ifdef __GLIBC__
			  yes
			  #endif
			  ], AC_DEFINE(HAVE_GETHOSTBYNAME_R, GHBN_R_GLIBC))
		;;
	esac
fi
dnl Check for usage of sockaddr_in in netdb.h
dnl somewhat ugly check, I check for presence of the string and that 
dnl compilation works. If either fails I assume it's not needed.
dnl Seems only to be needed on a patched version of solaris2.5.1, with
dnl netdb.h  version  1.18.
AC_MSG_CHECKING([if netdb.h requires netinet/in.h to be previously included])
AC_EGREP_CPP(sockaddr_in, 
	     [#include <netdb.h>],
	     AC_TRY_COMPILE([#include <netinet/in.h>
			     #include <netdb.h>], 
			    [return 0;],
			    need_in_h=yes, 
                            need_in_h=no),
             need_in_h=no)

if test $need_in_h = yes; then
	AC_DEFINE(NETDB_H_NEEDS_IN_H)
	AC_MSG_RESULT(yes)
else
	AC_MSG_RESULT(no)
fi

dnl Check for type socklen_t
dnl
AC_MSG_CHECKING([for socklen_t])
AC_TRY_COMPILE( [#include <sys/socket.h>], 
		[socklen_t test;],
		have_socklen_t=yes, 
                have_socklen_t=no),

if test $have_socklen_t = yes; then
	AC_DEFINE(HAVE_SOCKLEN_T)
	AC_MSG_RESULT(yes)
else
	AC_MSG_RESULT(no)
fi


dnl h_errno isn't always declared in netdb.h, and with some definitions
dnl (e.g. function call for thread-safe) a simple 'extern int' may conflict
dnl (we do assume that h_errno exists at all...)
AC_CACHE_CHECK([for h_errno declaration in netdb.h],
  ac_cv_decl_h_errno,
[AC_TRY_COMPILE([#include <netdb.h>], [int err = h_errno;],
  ac_cv_decl_h_errno=yes, ac_cv_decl_h_errno=no)])
if test $ac_cv_decl_h_errno = yes; then
  AC_DEFINE(H_ERRNO_DECLARED)
fi


dnl ----------------------------------------------------------------------
dnl Checks for header files.
dnl ----------------------------------------------------------------------

dnl We sometimes need EMU_THR_DEFS in order to find certain headers.
saved_cppflags=$CPPFLAGS
CPPFLAGS="$CPPFLAGS $EMU_THR_DEFS"

AC_HEADER_DIRENT
AC_HEADER_STDC
AC_HEADER_SYS_WAIT
AC_HEADER_TIME

dnl Interactive UX needs <net/errno.h> for socket related error codes.
dnl Some Linuxes needs <sys/socketio.h> instead of <sys/sockio.h>
dnl
AC_CHECK_HEADERS(fcntl.h limits.h unistd.h syslog.h dlfcn.h ieeefp.h \
                 sys/stropts.h sys/sysctl.h \
                 sys/ioctl.h sys/time.h sys/uio.h sys/sockio.h sys/socketio.h \
                 net/errno.h malloc.h mach-o/dyld.h arpa/nameser.h)

dnl Check if we have kernel poll support
AC_CHECK_HEADER(sys/devpoll.h, AC_DEFINE(HAVE_SYS_DEVPOLL_H))
AC_CHECK_HEADER(linux/kpoll.h, AC_DEFINE(HAVE_LINUX_KPOLL_H))
AC_CHECK_HEADER(sys/event.h, AC_DEFINE(HAVE_SYS_EVENT_H))

HAVE_VALGRIND=no
AC_CHECK_HEADER(valgrind/valgrind.h, HAVE_VALGRIND=yes)
AC_SUBST(HAVE_VALGRIND)

LM_DECL_SO_BSDCOMPAT
LM_DECL_INADDR_LOOPBACK
LM_DECL_SYS_ERRLIST

AC_CACHE_CHECK([if windows.h includes winsock2.h],
		erts_cv_windows_h_includes_winsock2_h,
		AC_TRY_COMPILE([#include <windows.h>
				],
			       [#ifndef _WINSOCK2API_
				#error winsock2.h not included
				#endif
				int i = 1;
				],
			       erts_cv_windows_h_includes_winsock2_h=yes,
			       erts_cv_windows_h_includes_winsock2_h=no))
if test $erts_cv_windows_h_includes_winsock2_h = yes; then
	AC_DEFINE(WINDOWS_H_INCLUDES_WINSOCK2_H, 1, \
[Define if windows.h includes winsock2.h])
fi

dnl restore CPPFLAGS
CPPFLAGS=$saved_cppflags

dnl ----------------------------------------------------------------------
dnl Checks for typedefs, structures, and compiler characteristics.
dnl ----------------------------------------------------------------------

AC_C_CONST
AC_TYPE_SIGNAL
AC_TYPE_OFF_T
AC_TYPE_PID_T
AC_TYPE_SIZE_T

AC_STRUCT_TM
LM_STRUCT_SOCKADDR_SA_LEN
LM_STRUCT_EXCEPTION

AC_CHECK_SIZEOF(char, 1)
AC_CHECK_SIZEOF(short, 2)dnl Assumes all cross compiling is to 32bit uP
AC_CHECK_SIZEOF(int, 4)dnl Assumes all cross compiling is to 32bit uP
AC_CHECK_SIZEOF(long, 4)dnl Assumes all cross compiling is to 32bit uP
AC_CHECK_SIZEOF(void *, 4)dnl Assumes all cross compiling is to 32bit uP
AC_CHECK_SIZEOF(long long, 0)

BITS64=

if test $ac_cv_sizeof_void_p = 8; then
  BITS64=yes
fi
AC_SUBST(BITS64)


dnl AC_CHECK_SIZEOF(size_t, 4)dnl Assumes all cross compiling is to 32bit uP
dnl
dnl The disabled one above does not include stddef.h, alas!
dnl
AC_CACHE_CHECK([size of size_t], ac_cv_sizeof_size_t, 
AC_TRY_RUN([
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
int main(int argc, char **argv) {
    FILE *f = fopen("conftestval", "w");
    if (! f)
	exit(1); /* Failed */
    fprintf(f, "%d\n", (int) sizeof(size_t));
    exit(0); /* OK */
}
], ac_cv_sizeof_size_t=`cat conftestval`
,  ac_cv_sizeof_size_t=0
,  ac_cv_sizeof_size_t=4))
AC_DEFINE_UNQUOTED(SIZEOF_SIZE_T, $ac_cv_sizeof_size_t)

dnl A standard size check does not include sys/types.h
dnl
AC_CACHE_CHECK([size of off_t], ac_cv_sizeof_off_t, 
AC_TRY_RUN([
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
int main(int argc, char **argv) {
    FILE *f = fopen("conftestval", "w");
    if (! f)
	exit(1); /* Failed */
    fprintf(f, "%d\n", (int) sizeof(off_t));
    exit(0); /* OK */
}
], ac_cv_sizeof_off_t=`cat conftestval`
,  ac_cv_sizeof_off_t=0
,  ac_cv_sizeof_off_t=4))
AC_DEFINE_UNQUOTED(SIZEOF_OFF_T, $ac_cv_sizeof_off_t)

AC_MSG_CHECKING([int/long/void*/size_t sizes])
AC_TRY_RUN([
#include <stdlib.h>
#include <stddef.h>
int main(int argc, char **argv) {
    if (sizeof(void *) >= 4 &&
	sizeof(void *) == sizeof(size_t) &&
	(sizeof(void *) == sizeof(int) || sizeof(void *) == sizeof(long))) {
	exit(0); /* OK */
    }
    exit(1); /* Failed */
}
],AC_MSG_RESULT(ok)
,AC_MSG_RESULT(failed)
AC_MSG_ERROR([Cannot handle this combination of int/long/void*/size_t sizes])
,AC_MSG_RESULT(ok))

AC_C_BIGENDIAN

dnl ----------------------------------------------------------------------
dnl Checks for library functions.
dnl ----------------------------------------------------------------------

dnl We may need the thread library and thread flags in order to find right stuff
saved_cppflags=$CPPFLAGS
CPPFLAGS="$CPPFLAGS $EMU_THR_DEFS"
saved_libs=$LIBS
LIBS="$LIBS $EMU_THR_X_LIBS"

dnl Check if we have these, in which case we'll try to build
dnl inet_gethost with ipv6 support.
AC_CHECK_FUNCS([getipnodebyname getipnodebyaddr])

AC_CHECK_FUNCS([ieee_handler fpsetmask finite isnan isinf res_gethostbyname dlopen \
		pread pwrite writev memmove strerror strerror_r strncasecmp \
		gethrtime localtime_r gmtime_r mremap memcpy mallopt \
		sbrk _sbrk __sbrk brk _brk __brk \
		flockfile])
AC_FUNC_SETVBUF_REVERSED

disable_vfork=false
if test "x$EMU_THR_LIB_NAME" != "x"; then
	AC_MSG_CHECKING([if vfork is known to hang multithreaded applications])
	case $host_os in
		osf*)
			AC_MSG_RESULT(yes)
			disable_vfork=true;;
		*)
			AC_MSG_RESULT(no);;
	esac
fi

if test $disable_vfork = false; then
	AC_FUNC_VFORK
	if test $ac_cv_func_vfork_works = no; then
		disable_vfork=true
	fi
fi

if test $disable_vfork = true; then
	AC_DEFINE(DISABLE_VFORK, 1, [Define if you want to disable vfork.])
fi

AC_FUNC_VPRINTF
AC_FUNC_MMAP

dnl The AC_DEFINEs are necessary for autoheader to work. :-(
dnl for gzio
LM_CHECK_FUNC_DECL(fread, [extern int fread();],,
                   AC_DEFINE(HAVE_CONFLICTING_FREAD_DECLARATION))

dnl Checking with TRY_LINK since putc_unlocked might be (probably is) a macro
AC_CACHE_CHECK([for putc_unlocked],
	erts_cv_putc_unlocked,
	AC_TRY_LINK([#include <stdio.h>],
		[int res = putc_unlocked('x',stdout);],
		erts_cv_putc_unlocked=yes,
             	erts_cv_putc_unlocked=no))
if test $erts_cv_putc_unlocked = yes; then
	AC_DEFINE(HAVE_PUTC_UNLOCKED, 1, [Define if you have putc_unlocked])
fi

dnl Checking with TRY_LINK since fwrite_unlocked might be a macro
AC_CACHE_CHECK([for fwrite_unlocked],
	erts_cv_fwrite_unlocked,
	AC_TRY_LINK([#include <stdio.h>],
		[size_t res = fwrite_unlocked(NULL,sizeof(char),0,stdout);],
		erts_cv_fwrite_unlocked=yes,
             	erts_cv_fwrite_unlocked=no))
if test $erts_cv_fwrite_unlocked = yes; then
	AC_DEFINE(HAVE_FWRITE_UNLOCKED, 1, [Define if you have fwrite_unlocked])
fi

dnl ----------------------------------------------------------------------
dnl Checks for features/quirks in the system that affects Erlang.
dnl ----------------------------------------------------------------------

AC_CACHE_CHECK([for 'end' symbol],
		erts_cv_have_end_symbol,
		[AC_TRY_LINK([],
			[extern char end; {char *x = &end; *x= 0;}],
			erts_cv_have_end_symbol=yes,
			erts_cv_have_end_symbol=no)])
if test $erts_cv_have_end_symbol = yes; then
	AC_DEFINE(HAVE_END_SYMBOL, 1, [Define if you have the 'end' symbol])
fi

AC_CACHE_CHECK([for '_end' symbol],
		erts_cv_have__end_symbol,
		[AC_TRY_LINK([],
			[extern char _end; {char *x = &_end; *x= 0;}],
			erts_cv_have__end_symbol=yes,
			erts_cv_have__end_symbol=no)])
if test $erts_cv_have__end_symbol = yes; then
	AC_DEFINE(HAVE__END_SYMBOL, 1, [Define if you have the '_end' symbol])
fi

AC_CACHE_CHECK([if __after_morecore_hook can track malloc()s core memory use],
		erts_cv___after_morecore_hook_can_track_malloc,
		[AC_TRY_RUN([
#include <stdlib.h>
#ifdef HAVE_MALLOC_H
#  include <malloc.h>
#endif
#if defined(HAVE_END_SYMBOL)
extern char end;
#elif defined(HAVE__END_SYMBOL)
extern char _end;
#endif
#ifndef USE_THREADS
#undef ETHR_PTHREADS
#endif

#ifdef ETHR_PTHREADS
#  ifdef ETHR_HAVE_PTHREAD_H
#    include <pthread.h>
#  else
#    ifdef ETHR_HAVE_MIT_PTHREAD_H
#      include <pthread/mit/pthread.h>
#    endif
#  endif
#  define N_THR 5
#else
#  define N_THR 1
#endif

static char *heap_start = NULL;
static char *heap_end = NULL;

void update_heap_size(void)
{
    heap_end = (char *) sbrk(0);
}

void init_hook(void)
{
#if defined(HAVE_END_SYMBOL)
    heap_start = &end;
#elif defined(HAVE__END_SYMBOL)
    heap_start = &_end;
#else
    heap_start = sbrk(0);
#endif
    __after_morecore_hook = update_heap_size;
}

void (*__malloc_initialize_hook) (void) = init_hook;

static int
check_malloc(int size)
{
    char *p = (char *) malloc(size);
    if (!heap_start || !heap_end) return 0;
    if (!p) return 0;
    if (p < heap_start || heap_end <= p) return 0;
    if (p + size < heap_start || heap_end < p + size) return 0;
    return 1;
}

#ifdef ETHR_PTHREADS
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
#endif

static void *
do_tests(void *vresp)
{
    int i, ok = 0;
#ifdef ETHR_PTHREADS
    if (pthread_mutex_lock(&mutex) != 0)
	return NULL;
#endif

    for (i = 0; i < 10; i++)
	if (!check_malloc(1000))
	    goto failed;
    for (i = 0; i < 100; i++)
	if (!check_malloc(1))
	    goto failed;
    if (!check_malloc(1024*1024+1))
	goto failed;
    if (!check_malloc(10*1024*1024+1))
	goto failed;
    ok = 1;

 failed:
#ifdef ETHR_PTHREADS
    if (pthread_mutex_unlock(&mutex) != 0)
	return NULL;
#endif
    if (ok)
	*((int *) vresp) = 0;
    return NULL;
}


int main(void)
{
    int res[N_THR], i;
#ifdef ETHR_PTHREADS
    pthread_t tid[N_THR];
#endif

#if defined(HAVE_MALLOPT) && defined(M_MMAP_MAX)
    (void) mallopt(M_MMAP_MAX, 0);
#endif

    for (i = 0; i < N_THR; i++)
	res[i] = 1;
#ifdef ETHR_PTHREADS
    for (i = 1; i < N_THR; i++)
	if (pthread_create(&tid[i], NULL, do_tests, &res[i]) != 0)
	    return 1;
#endif
    (void) do_tests(&res[0]);
#ifdef ETHR_PTHREADS
    for (i = 1; i < N_THR; i++)
	if (pthread_join(tid[i], NULL) != 0)
	    return 1;
#endif
    for (i = 0; i < N_THR; i++)
	if (res[i])
	    return 1;
    return 0;
}
	],
	erts_cv___after_morecore_hook_can_track_malloc=yes,
	erts_cv___after_morecore_hook_can_track_malloc=no,
	erts_cv___after_morecore_hook_can_track_malloc=no)])

if test $erts_cv___after_morecore_hook_can_track_malloc = yes; then
	AC_DEFINE(ERTS___AFTER_MORECORE_HOOK_CAN_TRACK_MALLOC, 1, \
[Define if __after_morecore_hook can track malloc()s core memory use.])
fi

if test $ac_cv_func_sbrk = yes; then
    AC_CACHE_CHECK([types of sbrk()s return value and argument],
		    erts_cv_sbrk_ret_arg_types,
		    [

	erts_cv_sbrk_ret_arg_types=unknown
	ret_types="void *,char *"
	arg_types="intptr_t,ptrdiff_t,int,long"
	save_ifs="$IFS"; IFS=","
	for rtype in $ret_types; do
	    for atype in $arg_types; do
		IFS=$save_ifs
		AC_TRY_COMPILE([#include <sys/types.h>
				#include <unistd.h>],
				[$rtype sbrk($atype incr);],
				[erts_cv_sbrk_ret_arg_types="$rtype,$atype"])
		IFS=","
		if test "$erts_cv_sbrk_ret_arg_types" != "unknown"; then
		    break 2
		fi
	    done
	done
	IFS=$save_ifs])
    
    if test "$erts_cv_sbrk_ret_arg_types" != "unknown"; then
	save_ifs="$IFS"; IFS=","
	read ret_type arg_type <<EOF
$erts_cv_sbrk_ret_arg_types
EOF
	IFS=$save_ifs
	AC_DEFINE_UNQUOTED(SBRK_RET_TYPE, $ret_type, \
[Define the sbrk() return type.])
	AC_DEFINE_UNQUOTED(SBRK_ARG_TYPE, $arg_type, \
[Define the sbrk() argument type.])
    fi
fi

if test $ac_cv_func_brk = yes; then
    AC_CACHE_CHECK([types of brk()s return value and argument],
		    erts_cv_brk_ret_arg_types,
		    [

	erts_cv_brk_ret_arg_types=unknown
	ret_types="int,long,char *,void *"
	arg_types="void *,const void *,char *,const char *"
	save_ifs="$IFS"; IFS=","
	for rtype in $ret_types; do
	    for atype in $arg_types; do
		IFS=$save_ifs
		AC_TRY_COMPILE([#include <sys/types.h>
				#include <unistd.h>],
				[$rtype brk($atype endds);],
				[erts_cv_brk_ret_arg_types="$rtype,$atype"])
		IFS=","
		if test "$erts_cv_brk_ret_arg_types" != "unknown"; then
		    break 2
		fi
	    done
	done
	IFS=$save_ifs])
    
    if test "$erts_cv_brk_ret_arg_types" != "unknown"; then
	save_ifs="$IFS"; IFS=","
	read ret_type arg_type <<EOF
$erts_cv_brk_ret_arg_types
EOF
	IFS=$save_ifs
	AC_DEFINE_UNQUOTED(BRK_RET_TYPE, $ret_type, \
[Define the brk() return type.])
	AC_DEFINE_UNQUOTED(BRK_ARG_TYPE, $arg_type, \
[Define the brk() argument type.])
    fi

fi

if test $ac_cv_func_sbrk = yes; then

    AC_CACHE_CHECK([if sbrk()/brk() wrappers can track malloc()s core memory use],
		    erts_cv_brk_wrappers_can_track_malloc,
		    [AC_TRY_RUN([
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#ifdef HAVE_DLFCN_H
#  include <dlfcn.h>
#endif

/*
 * Our implementation requires that we have sbrk(), and 'end' or '_end'.
 */

#if !defined(HAVE_SBRK)
#  error no sbrk()
#endif
#if defined(HAVE_END_SYMBOL)
extern char end;
#elif defined(HAVE__END_SYMBOL)
extern char _end;
#else
#  error no 'end' nor '_end'
#endif

#ifndef USE_THREADS
#undef ETHR_PTHREADS
#endif

#ifdef ETHR_PTHREADS
#  ifdef ETHR_HAVE_PTHREAD_H
#    include <pthread.h>
#  else
#    ifdef ETHR_HAVE_MIT_PTHREAD_H
#      include <pthread/mit/pthread.h>
#    endif
#  endif
#  define N_THR 5
#else
#  define N_THR 1
#endif

#define SBRK_IMPL(RET_TYPE, SBRK, ARG_TYPE)				\
RET_TYPE SBRK (ARG_TYPE);						\
static RET_TYPE (*real_ ## SBRK)(ARG_TYPE) = NULL;			\
RET_TYPE								\
SBRK (ARG_TYPE arg)							\
{									\
    RET_TYPE res;							\
    if (!real_ ## SBRK) real_ ## SBRK = dlsym(RTLD_NEXT, #SBRK);	\
    res = (*real_ ## SBRK)(arg);					\
    if (res != (RET_TYPE) -1) heap_end = (char *) (*real_ ## SBRK)(0);	\
    return res;								\
}

#define BRK_IMPL(RET_TYPE, BRK, ARG_TYPE)				\
RET_TYPE BRK (ARG_TYPE);						\
static RET_TYPE (*real_ ## BRK)(ARG_TYPE) = NULL;			\
RET_TYPE								\
BRK (ARG_TYPE arg)							\
{									\
    RET_TYPE res;							\
    if (!real_ ## BRK) real_ ## BRK = dlsym(RTLD_NEXT, #BRK);		\
    res = (*real_ ## BRK)(arg);						\
    if (res != (RET_TYPE) -1) heap_end = (char *) arg;			\
    return res;								\
}

static char *heap_start = NULL;
static char *heap_end = NULL;

SBRK_IMPL(SBRK_RET_TYPE, sbrk, SBRK_ARG_TYPE)
#ifdef HAVE_BRK
   BRK_IMPL(BRK_RET_TYPE, brk, BRK_ARG_TYPE)
#endif

#ifdef HAVE__SBRK
   SBRK_IMPL(SBRK_RET_TYPE, _sbrk, SBRK_ARG_TYPE)
#endif
#ifdef HAVE__BRK
   BRK_IMPL(BRK_RET_TYPE, _brk, BRK_ARG_TYPE)
#endif

#ifdef HAVE___SBRK
   SBRK_IMPL(SBRK_RET_TYPE, __sbrk, SBRK_ARG_TYPE)
#endif
#ifdef HAVE___BRK
   BRK_IMPL(BRK_RET_TYPE, __brk, BRK_ARG_TYPE)
#endif

static int
check_malloc(int size)
{
    char *p = (char *) malloc(size);
    if (!heap_start || !heap_end) return 0;
    if (!p) return 0;
    if (p < heap_start || heap_end <= p) return 0;
    if (p + size < heap_start || heap_end < p + size) return 0;
    return 1;
}

#ifdef ETHR_PTHREADS
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
#endif

static void *
do_tests(void *vresp)
{
    int i, ok = 0;
#ifdef ETHR_PTHREADS
    if (pthread_mutex_lock(&mutex) != 0)
	return NULL;
#endif

    for (i = 0; i < 10; i++)
	if (!check_malloc(1000))
	    goto failed;
    for (i = 0; i < 100; i++)
	if (!check_malloc(1))
	    goto failed;
    if (!check_malloc(1024*1024+1))
	goto failed;
    if (!check_malloc(10*1024*1024+1))
	goto failed;
    ok = 1;

 failed:
#ifdef ETHR_PTHREADS
    if (pthread_mutex_unlock(&mutex) != 0)
	return NULL;
#endif
    if (ok)
	*((int *) vresp) = 0;
    return NULL;
}


int main(void)
{
    int res[N_THR], i;
#ifdef ETHR_PTHREADS
    pthread_t tid[N_THR];
#endif
#if defined(HAVE_END_SYMBOL)
    heap_start = &end;
#elif defined(HAVE__END_SYMBOL)
    heap_start = &_end;
#endif

#if defined(HAVE_MALLOPT) && defined(M_MMAP_MAX)
    (void) mallopt(M_MMAP_MAX, 0);
#endif

    for (i = 0; i < N_THR; i++)
	res[i] = 1;
#ifdef ETHR_PTHREADS
    for (i = 1; i < N_THR; i++)
	if (pthread_create(&tid[i], NULL, do_tests, &res[i]) != 0)
	    return 1;
#endif
    (void) do_tests(&res[0]);
#ifdef ETHR_PTHREADS
    for (i = 1; i < N_THR; i++)
	if (pthread_join(tid[i], NULL) != 0)
	    return 1;
#endif
    for (i = 0; i < N_THR; i++)
	if (res[i])
	    return 1;
    return 0;
}
	],
	    erts_cv_brk_wrappers_can_track_malloc=yes,
	    erts_cv_brk_wrappers_can_track_malloc=no,
	    erts_cv_brk_wrappers_can_track_malloc=no)])
	if test $erts_cv_brk_wrappers_can_track_malloc = yes; then
		AC_DEFINE(ERTS_BRK_WRAPPERS_CAN_TRACK_MALLOC, 1, \
[Define if sbrk()/brk() wrappers can track malloc()s core memory use])
	fi
fi

dnl Restore LIBS
LIBS=$saved_libs
dnl restore CPPFLAGS
CPPFLAGS=$saved_cppflags

LM_SYS_IPV6
LM_SYS_MULTICAST
ERL_TIME_CORRECTION

AC_MSG_CHECKING([for unreliable floating point execptions])
AC_TRY_RUN([
/* fpe-test.c */
#include <stdio.h>
#include <signal.h>
#include <stdlib.h>

volatile int erl_fp_exception;

/* Is there no standard identifier for Darwin/MacOSX ? */
#if defined(__APPLE__) && defined(__MACH__) && !defined(__DARWIN__)
#define __DARWIN__ 1
#endif

#if (defined(__i386__) || defined(__x86_64__)) && defined(__GNUC__) && !defined(__CYGWIN__)

static void unmask_x87(void)
{
    unsigned short cw;
    __asm__ __volatile__("fstcw %0" : "=m"(cw));
    cw &= ~(0x01|0x04|0x08);   /* unmask IM, ZM, OM */
    __asm__ __volatile__("fldcw %0" : : "m"(cw));
}

static void unmask_sse2(void)
{
    unsigned int mxcsr;
    __asm__ __volatile__("stmxcsr %0" : "=m"(mxcsr));
    mxcsr &= ~(0x003F|0x0680); /* clear exn flags, unmask OM, ZM, IM (not PM, UM, DM) */
    __asm__ __volatile__("ldmxcsr %0" : : "m"(mxcsr));
}

#if defined(__x86_64__) || defined(__DARWIN__)
static inline int cpu_has_sse2(void) { return 1; }
#else /* !__x86_64__ */
/*
 * Check if an x86-32 processor has SSE2.
 */
static unsigned int xor_eflags(unsigned int mask)
{
    unsigned int eax, edx;

    eax = mask;			/* eax = mask */
    __asm__("pushfl\n\t"
	    "popl %0\n\t"	/* edx = original EFLAGS */
	    "xorl %0, %1\n\t"	/* eax = mask ^ EFLAGS */
	    "pushl %1\n\t"
	    "popfl\n\t"		/* new EFLAGS = mask ^ original EFLAGS */
	    "pushfl\n\t"
	    "popl %1\n\t"	/* eax = new EFLAGS */
	    "xorl %0, %1\n\t"	/* eax = new EFLAGS ^ old EFLAGS */
	    "pushl %0\n\t"
	    "popfl"		/* restore original EFLAGS */
	    : "=d"(edx), "=a"(eax)
	    : "1"(eax));
    return eax;
}

static __inline__ unsigned int cpuid_eax(unsigned int op)
{
    unsigned int eax;
    __asm__("cpuid"
	    : "=a"(eax)
	    : "0"(op)
	    : "bx", "cx", "dx");
    return eax;
}

static __inline__ unsigned int cpuid_edx(unsigned int op)
{
    unsigned int eax, edx;
    __asm__("cpuid"
	    : "=a"(eax), "=d"(edx)
	    : "0"(op)
	    : "bx", "cx");
    return edx;
}

/* The AC bit, bit #18, is a new bit introduced in the EFLAGS
 * register on the Intel486 processor to generate alignment
 * faults. This bit cannot be set on the Intel386 processor.
 */
static __inline__ int is_386(void)
{
    return ((xor_eflags(1<<18) >> 18) & 1) == 0;
}

/* Newer x86 processors have a CPUID instruction, as indicated by
 * the ID bit (#21) in EFLAGS being modifiable.
 */
static __inline__ int has_CPUID(void)
{
    return (xor_eflags(1<<21) >> 21) & 1;
}

static int cpu_has_sse2(void)
{
    unsigned int maxlev, features;
    static int has_sse2 = -1;

    if (has_sse2 >= 0)
	return has_sse2;
    has_sse2 = 0;

    if (is_386())
	return 0;
    if (!has_CPUID())
	return 0;
    maxlev = cpuid_eax(0);
    /* Intel A-step Pentium had a preliminary version of CPUID.
       It also didn't have SSE2. */
    if ((maxlev & 0xFFFFFF00) == 0x0500)
	return 0;
    /* If max level is zero then CPUID cannot report any features. */
    if (maxlev == 0)
	return 0;
    features = cpuid_edx(1);
    has_sse2 = (features & (1 << 26)) != 0;

    return has_sse2;
}
#endif /* !__x86_64__ */

static void unmask_fpe(void)
{
    unmask_x87();
    if (cpu_has_sse2())
	unmask_sse2();
}

static __inline__ int check_fpe(double f)
{
    __asm__ __volatile__("fwait" : "=m"(erl_fp_exception) : "m"(f));
    if (!erl_fp_exception)
       return 0;
    __asm__ __volatile__("fninit");
    unmask_fpe();
    return 1;
}

#elif defined(__sparc__) && defined(__linux__)

static void unmask_fpe(void)
{
    unsigned long fsr;

    __asm__("st %%fsr, %0" : "=m"(fsr));
    fsr &= ~(0x1FUL << 23);	/* clear FSR[TEM] field */
    fsr |= (0x1AUL << 23);	/* enable NV, OF, DZ exceptions */
    __asm__ __volatile__("ld %0, %%fsr" : : "m"(fsr));
}

static __inline__ int check_fpe(double f)
{
    __asm__ __volatile__("" : "=m"(erl_fp_exception) : "em"(f));
    return erl_fp_exception;
}

#elif (defined(__powerpc__) && defined(__linux__)) || (defined(__ppc__) && defined(__DARWIN__))

#if defined(__linux__)
#include <sys/prctl.h>

static void set_fpexc_precise(void)
{
    if (prctl(PR_SET_FPEXC, PR_FP_EXC_PRECISE) < 0) {
	perror("PR_SET_FPEXC");
	exit(1);
    }
}

#elif defined(__DARWIN__)

#include <mach/mach.h>
#include <pthread.h>

/*
 * FE0 FE1	MSR bits
 *  0   0	floating-point exceptions disabled
 *  0   1	floating-point imprecise nonrecoverable
 *  1   0	floating-point imprecise recoverable
 *  1   1	floating-point precise mode
 *
 * Apparently:
 * - Darwin 5.5 (MacOS X <= 10.1) starts with FE0 == FE1 == 0,
 *   and resets FE0 and FE1 to 0 after each SIGFPE.
 * - Darwin 6.0 (MacOS X 10.2) starts with FE0 == FE1 == 1,
 *   and does not reset FE0 or FE1 after a SIGFPE.
 */
#define FE0_MASK	(1<<11)
#define FE1_MASK	(1<<8)

/* a thread cannot get or set its own MSR bits */
static void *fpu_fpe_enable(void *arg)
{
    thread_t t = *(thread_t*)arg;
    struct ppc_thread_state state;
    unsigned int state_size = PPC_THREAD_STATE_COUNT;

    if (thread_get_state(t, PPC_THREAD_STATE, (natural_t*)&state, &state_size) != KERN_SUCCESS) {
	perror("thread_get_state");
	exit(1);
    }
    if ((state.srr1 & (FE1_MASK|FE0_MASK)) != (FE1_MASK|FE0_MASK)) {
#if 0
	/* This would also have to be performed in the SIGFPE handler
	   to work around the MSR reset older Darwin releases do. */
	state.srr1 |= (FE1_MASK|FE0_MASK);
	thread_set_state(t, PPC_THREAD_STATE, (natural_t*)&state, state_size);
#else
	fprintf(stderr, "srr1 == 0x%08x, your Darwin is too old\n", state.srr1);
	exit(1);
#endif
    }
    return NULL; /* Ok, we appear to be on Darwin 6.0 or later */
}

static void set_fpexc_precise(void)
{
    thread_t self = mach_thread_self();
    pthread_t enabler;

    if (pthread_create(&enabler, NULL, fpu_fpe_enable, &self)) {
	perror("pthread_create");
    } else if (pthread_join(enabler, NULL)) {
	perror("pthread_join");
    }
}

#endif

static void set_fpscr(unsigned int fpscr)
{
    union {
	double d;
	unsigned int fpscr[2];
    } u;
    u.fpscr[0] = 0xFFF80000;
    u.fpscr[1] = fpscr;
    __asm__ __volatile__("mtfsf 255,%0" : : "f"(u.d));
}

static void unmask_fpe(void)
{
    set_fpexc_precise();
    set_fpscr(0x80|0x40|0x10);	/* VE, OE, ZE; not UE or XE */
}

static __inline__ int check_fpe(double f)
{
    __asm__ __volatile__("" : "=m"(erl_fp_exception) : "fm"(f));
    return erl_fp_exception;
}

#else

#include <ieeefp.h>
#define unmask_fpe()   fpsetmask(FP_X_INV | FP_X_OFL | FP_X_DZ)
static __inline__ int check_fpe(double f)
{
    __asm__ __volatile__("" : "=m"(erl_fp_exception) : "g"(f));
    return erl_fp_exception;
}

#endif

#if (defined(__linux__) && (defined(__i386__) || defined(__x86_64__) || defined(__sparc__) || defined(__powerpc__))) || (defined(__DARWIN__) && (defined(__i386__) || defined(__ppc__)))

#if defined(__linux__) && defined(__i386__)
#include <asm/sigcontext.h>
#endif
#include <ucontext.h>
#include <string.h>

static void fpe_sig_action(int sig, siginfo_t *si, void *puc)
{
    ucontext_t *uc = puc;
#if defined(__linux__)
#if defined(__x86_64__)
    mcontext_t *mc = &uc->uc_mcontext;
    fpregset_t fpstate = mc->fpregs;
    fpstate->mxcsr = 0x1F80;
    fpstate->swd &= ~0xFF;
#elif defined(__i386__)
    mcontext_t *mc = &uc->uc_mcontext;
    fpregset_t fpstate = mc->fpregs;
    if ((fpstate->status >> 16) == X86_FXSR_MAGIC)
	((struct _fpstate*)fpstate)->mxcsr = 0x1F80;
    fpstate->sw &= ~0xFF;
#elif defined(__sparc__)
    /* on SPARC the 3rd parameter points to a sigcontext not a ucontext */
    struct sigcontext *sc = (struct sigcontext*)puc;
    sc->si_regs.pc = sc->si_regs.npc;
    sc->si_regs.npc = (unsigned long)sc->si_regs.npc + 4;
#elif defined(__powerpc__)
#if defined(__powerpc64__)
    mcontext_t *mc = &uc->uc_mcontext;
    unsigned long *regs = &mc->gp_regs[0];
#else
    mcontext_t *mc = uc->uc_mcontext.uc_regs;
    unsigned long *regs = &mc->gregs[0];
#endif
    regs[PT_NIP] += 4;
    regs[PT_FPSCR] = 0x80|0x40|0x10;	/* VE, OE, ZE; not UE or XE */
#endif
#elif defined(__DARWIN__) && defined(__i386__)
    mcontext_t mc = uc->uc_mcontext;
    i386_float_state_t *fpstate = &mc->fs;
    fpstate->fpu_mxcsr = 0x1F80;
    *(unsigned short *)&fpstate->fpu_fsw &= ~0xFF;
#elif defined(__DARWIN__) && defined(__ppc__)
    mcontext_t mc = uc->uc_mcontext;
    mc->ss.srr0 += 4;
    mc->fs.fpscr = 0x80|0x40|0x10;
#endif
    erl_fp_exception = 1;
}

static void do_init(void)
{
    struct sigaction act;
    memset(&act, 0, sizeof act);
    act.sa_sigaction = fpe_sig_action;
    act.sa_flags = SA_SIGINFO;
    sigaction(SIGFPE, &act, NULL);
    unmask_fpe();
}

#else

static void fpe_sig_handler(int sig)
{
    erl_fp_exception = 1;
}

static void do_init(void)
{
    signal(SIGFPE, fpe_sig_handler);
    unmask_fpe();
}

#endif

double a = 3.23e133;
double b = 3.57e257;
double res;

void do_fmul(void)
{
    res = a * b;
}

int do_check(void)
{
    if (check_fpe(res)) {
       fprintf(stderr, "res = %g, FPE worked\n", res);
       return 0;
    } else {
       fprintf(stderr, "res = %g, FPE failed\n", res);
       return 1;
    }
}

int main(int argc, const char **argv)
{
    if (argc == 3) {
       a = atof(argv[1]);
       b = atof(argv[2]);
    }
    do_init();
    do_fmul();
    return do_check();
}
], erl_ok=reliable, erl_ok=unreliable, erl_ok=unreliable)
if test $erl_ok = unreliable; then
    AC_DEFINE(NO_FPE_SIGNALS)
    AC_MSG_RESULT([unreliable; testing in software instead])
else
    AC_MSG_RESULT(reliable)
fi

dnl
dnl Check if gethrvtime is working, and if to use procfs ioctl
dnl or (yet to be written) write to the procfs ctl file.
dnl

AC_MSG_CHECKING([if gethrvtime works and how to use it])
AC_TRY_RUN([
/* gethrvtime procfs ioctl test */
/* These need to be undef:ed to not break activation of
 * micro level process accounting on /proc/self 
 */
#ifdef _LARGEFILE_SOURCE
#  undef _LARGEFILE_SOURCE
#endif
#ifdef _FILE_OFFSET_BITS
#  undef _FILE_OFFSET_BITS
#endif
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <stdio.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/signal.h>
#include <sys/fault.h>
#include <sys/syscall.h>
#include <sys/procfs.h>
#include <fcntl.h>

int main() {
    long msacct = PR_MSACCT;
    int fd;
    long long start, stop;
    int i;
    pid_t pid = getpid();
    char proc_self[30] = "/proc/";

    sprintf(proc_self+strlen(proc_self), "%lu", (unsigned long) pid);
    if ( (fd = open(proc_self, O_WRONLY)) == -1)
	exit(1);
    if (ioctl(fd, PIOCSET, &msacct) < 0)
	exit(2);
    if (close(fd) < 0)
	exit(3);
    start = gethrvtime();
    for (i = 0; i < 100; i++)
	stop = gethrvtime();
    if (start == 0)
	exit(4);
    if (start == stop)
	exit(5);
    exit(0); return 0;
}
], erl_gethrvtime=procfs_ioctl, erl_gethrvtime=false, erl_gethrvtime=false)
case $erl_gethrvtime in
  procfs_ioctl)
	AC_DEFINE(HAVE_GETHRVTIME_PROCFS_IOCTL)
	AC_MSG_RESULT(uses ioctl to procfs)
	;;
  *)
	AC_MSG_RESULT(not working)

	dnl
	dnl Check if clock_gettime (linux) is working
	dnl

	AC_MSG_CHECKING([if clock_gettime works])
	save_libs=$LIBS
	LIBS="-lrt"
	AC_TRY_RUN([
	#include <stdlib.h>
	#include <unistd.h>
	#include <string.h>
	#include <stdio.h>
	#include <time.h>
	int main() {
	    long long start, stop;
	    int i;
	    struct timespec tp;

	    if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &tp) < 0)
	      exit(1);
	    start = ((long long)tp.tv_sec * 1000000000LL) + (long long)tp.tv_nsec;
	    for (i = 0; i < 100; i++)
	      clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &tp);
	    stop = ((long long)tp.tv_sec * 1000000000LL) + (long long)tp.tv_nsec;
	    if (start == 0)
	      exit(4);
	    if (start == stop)
	      exit(5);
	    exit(0); return 0;
	  }
	], erl_clock_gettime=true, erl_clock_gettime=false, erl_clock_gettime=false)
	LIBS=$save_libs
	case $erl_clock_gettime in
	  true)
		AC_DEFINE(HAVE_CLOCK_GETTIME)
		AC_MSG_RESULT(using clock_gettime)
		LIBRT=-lrt
		;;
	  *)
		AC_MSG_RESULT(not working)
		LIBRT=
		;;
	esac
	AC_SUBST(LIBRT)
	;;
esac

dnl
dnl Some operating systems allow you to redefine FD_SETSIZE to be able
dnl to select on more than the default number of file descriptors.
dnl We first discovered this in BSD/OS where the default is ridiculously
dnl low (256). But since we use a lot of file descriptors we found the
dnl need to go over the limit in other os's as well. Since FD_SETSIZE 
dnl must be defined before pulling in sys/types.h the actual number
dnl of file descriptors is set in acconfig.h and will thus be in config.h
dnl which *always* should be included first.
dnl

AC_MSG_CHECKING([whether to redefine FD_SETSIZE])
case $host_os in
  bsdi*)
	AC_DEFINE(REDEFINE_FD_SETSIZE)
	AC_MSG_RESULT(yes)
	;;
  *)
	AC_MSG_RESULT(no)
	;;
esac



dnl ----------------------------------------------------------------------
dnl Tests related to configurable options given on command line
dnl (using the --disable, --enable and --with switches).
dnl ----------------------------------------------------------------------

#
# Check if we should compile TSP app
#

TSP_APP=
if test X${enable_tsp} = Xyes; then
  TSP_APP=tsp
fi
AC_SUBST(TSP_APP)

#
# Check if we should build hybrid emulator
#

case $host_os in
    win32|vxworks|ose) # vxworks and ose have their own "configure scripts"...
	ERTS_BUILD_HYBRID_EMU=no;;
    *)
	AC_DEFINE(ERTS_HAVE_HYBRID_EMU, 1, [Define if the hybrid emulator is built])
	ERTS_BUILD_HYBRID_EMU=yes;;
esac

AC_SUBST(ERTS_BUILD_HYBRID_EMU)

#
# Check if we should enable HiPE.
#

HIPE_ENABLED=
HIPE_HELPERS=

# if not disabled, autoenable HiPE on known supported platforms
if test X${enable_hipe} != Xno; then
  case "$ARCH-$OPSYS" in
    ultrasparc-sol2|ultrasparc-linux|x86-sol2)
      if test X$ac_cv_sizeof_void_p != X4; then
       AC_MSG_WARN([HiPE is not supported in 64-bit builds])
      else
       enable_hipe=yes
      fi;;
    x86-linux|amd64-linux|ppc-linux|ppc-darwin|arm-linux)
      enable_hipe=yes
      ;;
  esac
fi

if test X${enable_hipe} = Xyes; then
  if test X$ac_cv_sizeof_void_p != X4 -a X$ARCH != Xamd64 -a X$ARCH != Xppc64; then
	AC_MSG_WARN([HiPE is not supported in 64-bit builds])
  else
     HIPE_ENABLED=yes
     AC_DEFINE(HIPE)
     HIPE_HELPERS="xmerl syntax_tools edoc"
     ENABLE_ALLOC_TYPE_VARS="$ENABLE_ALLOC_TYPE_VARS hipe"
  fi
fi
AC_SUBST(HIPE_HELPERS)
AC_SUBST(HIPE_ENABLED)

#
# Check if HiPE should use a standard installation of perfctr.
#
AC_SUBST(USE_PERFCTR)
if test "x$HIPE_ENABLED" = "xyes" ; then
  if test "x$with_perfctr" = "x" ; then
      AC_CHECK_LIB(perfctr, vperfctr_info, [USE_PERFCTR=1
	  AC_DEFINE(USE_PERFCTR)])
  elif test "x$with_perfctr" != "xno" ; then
      USE_PERFCTR=1
  fi
fi

#
# Check if we should use elib_malloc.
#

if test X${enable_elib_malloc} = Xyes; then
 AC_DEFINE(ENABLE_ELIB_MALLOC)
 AC_DEFINE(ELIB_HEAP_SBRK)
 AC_DEFINE(ELIB_ALLOC_IS_CLIB)
 AC_DEFINE(ELIB_SORTED_BLOCKS)
fi

#
# Check if we should try to use kernel poll
#
if test X${enable_kernel_poll} = Xyes; then
  AC_DEFINE(ENABLE_KERNEL_POLL)
fi

#
# Check for working poll().
#
AC_MSG_CHECKING([for working poll()])
AC_TRY_RUN([
#include <poll.h>
main()
{
#ifdef _POLL_EMUL_H_
  exit(1); /* Implemented using select() -- fail */
#else
  struct pollfd fds[1];
  int fd;
  fd = open("/dev/null", 1);
  fds[0].fd = fd;
  fds[0].events = POLLIN;
  fds[0].revents = 0;
  if (poll(fds, 1, 0) < 0 || (fds[0].revents & POLLNVAL) != 0) {
    exit(1);  /* Does not work for devices -- fail */
  }
  exit(0);
#endif
}
], poll_works=true, poll_works=false, poll_works=false)
case $poll_works in
true)
	AC_MSG_RESULT(ok)
	;;
*)
	AC_DEFINE(USE_SELECT)
	AC_MSG_RESULT(broken or based on select())
	;;
esac

saved_cppflags=$CPPFLAGS
CPPFLAGS="$CPPFLAGS $EMU_THR_DEFS"
saved_libs=$LIBS
LIBS="$LIBS $EMU_THR_X_LIBS"

AC_CACHE_CHECK([for presens of poll()/select() bug when another thread closes fd],
    erts_cv_selecter_thr_closed_fd_bug,
    [
	case $enable_threads-$ETHR_THR_LIB_BASE in
	    no-*|*-win32_threads|*-pthread) ;;
	    *) AC_MSG_ERROR([Unexpected thread lib $ETHR_THR_LIB_BASE]);;
	esac
	case $enable_threads-$host_os in
	    *-win32)
		erts_cv_selecter_thr_closed_fd_bug=no;;
	    no-*)
		erts_cv_selecter_thr_closed_fd_bug=irrelevant;;
	    *)
		AC_TRY_RUN([
#ifndef USE_SELECT
#include <poll.h>
#endif
#ifdef SYS_SELECT_H
#include <sys/select.h>
#else
#include <sys/time.h>
#include <sys/types.h>
#endif
#include <unistd.h>
#include <pthread.h>
#include <stdlib.h>
#include <errno.h>

#define EXIT exit(__LINE__)

#ifndef ETHR_PTHREADS
#error "This test expects pthreads being used"
#endif

static pthread_mutex_t mtx = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t cnd = PTHREAD_COND_INITIALIZER;
static int timeout = 0;
static int result = -1;
static int fd;

void my_usleep(long usecs) {
    struct timeval tv; tv.tv_sec = usecs/1000000; tv.tv_usec = usecs%1000000;
    if (select (0, NULL, NULL, NULL, &tv) != 0) EXIT;
}

void *watchdog(void *unused) {
    my_usleep(200000);
    if (pthread_mutex_lock(&mtx) != 0) EXIT;
    timeout = 1;
    if (pthread_cond_signal(&cnd) != 0) EXIT;
    if (pthread_mutex_unlock(&mtx) != 0) EXIT;
    return NULL;
}

#ifdef USE_SELECT
void *
selecter(void *unused) {
    int sres;
    int select_errno;
    fd_set rfds;
    fd_set efds;
    FD_ZERO(&rfds);
    FD_ZERO(&efds);
    FD_SET(fd, &rfds);
    FD_SET(fd, &efds);
    sres = select(fd+1, &rfds, NULL, &efds, NULL);
    select_errno = sres < 0 ? errno : 0;
    if (sres > 1) EXIT;
    if (pthread_mutex_lock(&mtx) != 0) EXIT;
    result = select_errno;
    if (pthread_cond_signal(&cnd) != 0) EXIT;
    if (pthread_mutex_unlock(&mtx) != 0) EXIT;
    return NULL;
}
#else
void *
selecter(void *unused) {
    int poll_errno;
    int pres;
    static struct pollfd poll_fd;
    poll_fd.fd = fd;
    poll_fd.events = POLLIN;
    poll_fd.revents = 0;
    pres = poll(&poll_fd, 1, -1);
    poll_errno = pres < 0 ? errno : 0;
    if (pres > 1) EXIT;
    if (pthread_mutex_lock(&mtx) != 0) EXIT;
    result = poll_errno;
    if (pthread_cond_signal(&cnd) != 0) EXIT;
    if (pthread_mutex_unlock(&mtx) != 0) EXIT;
    return NULL;
}
#endif

int main(void) {
    int fds[2];
    pthread_t wd_tid;
    pthread_t p_tid;
    if (pipe(fds) != 0) EXIT;
    fd = fds[1];
    if (pthread_create(&wd_tid, NULL, watchdog, NULL) != 0) EXIT;
    if (pthread_create(&p_tid, NULL, selecter, NULL) != 0) EXIT;
    my_usleep(100000);
    if (close(fds[1]) != 0) EXIT;
    if (pthread_mutex_lock(&mtx) != 0) EXIT;
    while (!timeout && result < 0) {
	int res = pthread_cond_wait(&cnd, &mtx);
	if (res != 0 && res != EINTR) EXIT;
    }
    if (timeout) exit(1); /* poll()/select() did not return on close! */
    if (pthread_mutex_unlock(&mtx) != 0) EXIT;
    return 0;
}
			    ],
			    erts_cv_selecter_thr_closed_fd_bug=no,
			    erts_cv_selecter_thr_closed_fd_bug=yes,
			    erts_cv_selecter_thr_closed_fd_bug=unknown)
	esac
    ])

dnl Restore LIBS
LIBS=$saved_libs
dnl restore CPPFLAGS
CPPFLAGS=$saved_cppflags

if test $erts_cv_selecter_thr_closed_fd_bug = yes; then
   AC_DEFINE(ERTS_SELECTER_THR_CLOSED_FD_BUG, 1, \
[Define if poll()/select() bug when another thread closes fd is present.])
fi

dnl ----------------------------------------------------------------------
dnl Stuff that should be moved into their respective application
dnl ----------------------------------------------------------------------

dnl crypto
#--------------------------------------------------------------------
# Dynamic Erlang Drivers
#
# Linking to produce dynamic Erlang drivers to be loaded by Erlang's
# Dynamic Driver Loader and Linker (DDLL). Below the prefix DED is an
# abbreviation for `Dynamic Erlang Driver'.
#
# For DED we need something quite sloppy, which allows undefined references 
# (notably driver functions) in the resulting shared library. 
# Example of Makefile rule (and settings of macros):
#
# LIBS = @LIBS@
# LD = @DED_LD@
# LDFLAGS = @DED_LDFLAGS@
# soname = @ldsoname@
#
# my_drv.so:   my_drv.o my_utils.o
#              $(LD) $(LDFLAGS) $(soname) $@ -o $@ $^ -lc $(LIBS)
#
#--------------------------------------------------------------------

DED_CFLAGS="$CFLAGS $CPPFLAGS $EMU_THR_DEFS"
if test "x$GCC" = xyes; then
    DED_CFLAGS="$DED_CFLAGS -fPIC"
fi

DED_LD=ld
DED_LD_FLAG_RUNTIME_LIBRARY_PATH="-R"
STATIC_CFLAGS=""

case $host_os in
	win32)
		DED_LD=ld.sh	
		DED_LDFLAGS="-dll"
		DED_LD_FLAG_RUNTIME_LIBRARY_PATH=
	;;
	solaris2*|sysv4*)
		DED_LDFLAGS="-G"
	;;
	aix4*)
		DED_LDFLAGS="-G -bnoentry -bexpall"
	;;
	freebsd2*)
		# Non-ELF GNU linker
		DED_LDFLAGS="-Bshareable"
	;;
	darwin*)
		# Mach-O linker: a shared lib and a loadable
		# object file is not the same thing.
		DED_LDFLAGS="-bundle -flat_namespace -undefined suppress"
		DED_CFLAGS="$DED_CFLAGS -fno-common"
		DED_LD="$CC"
		DED_LD_FLAG_RUNTIME_LIBRARY_PATH=
		STATIC_CFLAGS="-mdynamic-no-pic"
	;;
	osf*)
		# NOTE! Whitespace after -rpath is important.
		DED_LD_FLAG_RUNTIME_LIBRARY_PATH="-rpath "
		DED_LDFLAGS="-shared -expect_unresolved '*'"
	;;
	*)
		# assume GNU linker and ELF
		DED_LDFLAGS="-shared"
	;;
esac


AC_MSG_CHECKING(for compiler flags for loadable drivers)
AC_MSG_RESULT([$DED_CFLAGS])
AC_MSG_CHECKING(for linker for loadable drivers)
AC_MSG_RESULT([$DED_LD])
AC_MSG_CHECKING(for linker flags for loadable drivers)
AC_MSG_RESULT([$DED_LDFLAGS])
AC_MSG_CHECKING(for 'runtime library path' linker flag)
if test "x$DED_LD_FLAG_RUNTIME_LIBRARY_PATH" != "x"; then
	AC_MSG_RESULT([$DED_LD_FLAG_RUNTIME_LIBRARY_PATH])
else
	AC_MSG_RESULT([not found])
fi

AC_SUBST(DED_CFLAGS)
AC_SUBST(DED_LD)
AC_SUBST(DED_LDFLAGS)
AC_SUBST(DED_LD_FLAG_RUNTIME_LIBRARY_PATH)
AC_SUBST(STATIC_CFLAGS)

dnl
dnl We should look for a compiler that handles jump tables, for beam_emu 
dnl to be optimizes
dnl

LM_FIND_EMU_CC

dnl
dnl SSL, SSH and CRYPTO need the OpenSSL libraries
dnl
dnl Check flags --with-ssl, --without-ssl --with-ssl=PATH.
dnl If no option is given or --with-ssl is set without a path then we
dnl search for OpenSSL libraries and header files in the standard locations. 
dnl If set to --without-ssl we disable the use of SSL, SSH and CRYPTO.
dnl If set to --with-ssl=PATH we use that path as the prefix, i.e. we
dnl use "PATH/include" and "PATH/lib".

AC_SUBST(SSL_APP)
AC_SUBST(CRYPTO_APP)
AC_SUBST(SSH_APP)
AC_SUBST(SSL_INCLUDE)
AC_SUBST(SSL_ROOT)
AC_SUBST(SSL_LIBDIR)
AC_SUBST(OPENSSL_CMD)
AC_ARG_WITH(ssl,
[  --with-ssl=PATH         specify location of OpenSSL include and lib
  --with-ssl              use SSL (default)
  --without-ssl           don't use SSL])


# Remove all SKIP files from previous runs
for a in ssl crypto ssh; do
  /bin/rm -f $ERL_TOP/lib/$a/SKIP
done

if test "x$with_ssl" = "xno"; then
    SSL_APP=
    CRYPTO_APP=
    SSH_APP=
elif test "x$with_ssl" = "xyes" -o "x$with_ssl" = "x" ;then
    # On windows, we could try to find the installation
    # of Shining Light OpenSSL, which can be found by poking in
    # the uninstall section in the registry, it's worth a try...
    extra_dir=""
    if  test "x$MIXED_CYGWIN" = "xyes"; then
    	AC_CHECK_PROG(REGTOOL, regtool, regtool, false)
	if test "$ac_cv_prog_REGTOOL" != false; then
		wrp="/machine/software/microsoft/windows/currentversion/"
		urp="uninstall/openssl_is1/inno setup: app path"
		rp="$wrp$urp"
		if regtool -q get "$rp" > /dev/null; then
			ssl_install_dir=`regtool -q get "$rp"`
			# Try hard to get rid of spaces...
			if cygpath -d "$ssl_install_dir" > /dev/null 2>&1; then
				ssl_install_dir=`cygpath -d "$ssl_install_dir"`
			fi
			extra_dir=`cygpath $ssl_install_dir`
		fi
	fi
    fi
    # We search for OpenSSL in the common OS standard locations.
    SSL_APP=ssl
    CRYPTO_APP=crypto
    SSH_APP=ssh

    AC_MSG_CHECKING(for OpenSSL >= 0.9.7 in standard locations) 
    for dir in $extra_dir /cygdrive/c/OpenSSL /usr/sfw \
		/usr/local /usr /usr/pkg \
		/usr/local/openssl /usr/lib/openssl /usr/openssl \
		/usr/local/ssl /usr/lib/ssl /usr/ssl
	do
       if test -f $dir/include/openssl/opensslv.h; then
		is_real_ssl=yes
		SSL_ROOT="$dir"
		if test "x$MIXED_CYGWIN" = "xyes" ; then
			if test -f "$dir/lib/VC/ssleay32.lib" -o \
				-f "$dir/lib/VC/openssl.lib"; then 
				SSL_LIBDIR="$dir/lib/VC"
			elif test -f "$dir/lib/ssleay32.lib" -o \
				-f "$dir/lib/openssl.lib"; then
				SSL_LIBDIR="$dir/lib"
			else
				is_real_ssl=no
			fi
		else
			SSL_LIBDIR="$dir/lib"
		fi
		SSL_BINDIR="$dir/bin"
dnl 		Should one use EXEEXT or ac_exeext?
		if test -f "$SSL_BINDIR/openssl$EXEEXT"; then
			if "$SSL_BINDIR/openssl" version > /dev/null 2>&1; then
				OPENSSL_CMD="$SSL_BINDIR/openssl"
			else
				is_real_ssl=no
			fi
		else
			is_real_ssl=no
		fi
		if test "x$is_real_ssl" = "xyes" ; then
			SSL_INCLUDE="-I$dir/include"
			old_CPPFLAGS=$CPPFLAGS
			CPPFLAGS=$SSL_INCLUDE
			AC_EGREP_CPP(yes,[
#include <openssl/opensslv.h>
#if OPENSSL_VERSION_NUMBER >= 0x0090700fL
  yes
#endif
			],[
			AC_MSG_RESULT([$dir])
			ssl_found=yes
			],[
			SSL_APP=
			ssl_found=no
         		])
         		CPPFLAGS=$old_CPPFLAGS
	 		if test "x$ssl_found" = "xyes" ; then
	   			break;
         		fi
		fi	
       fi
    done

    if test "x$ssl_found" != "xyes" ; then
	dnl 
	dnl If no SSL found above, check whether we are running on OpenBSD.
	dnl
	case $host_os in
	openbsd*)
	       if test -f /usr/include/openssl/opensslv.h; then
		  # Trust OpenBSD to have everything the in the correct locations.
		  ssl_found=yes
		  SSL_ROOT="/usr/sbin"
	          AC_MSG_RESULT([$SSL_ROOT])
		  SSL_LIB="/usr/lib"
		  SSL_BINDIR="/usr/sbin"
		  OPENSSL_CMD="$SSL_BINDIR/openssl"
		fi
		;;
	esac
    fi

    if test "x$ssl_found" != "xyes" ; then
       AC_MSG_RESULT([no])
       SSL_APP=
       CRYPTO_APP=
       SSH_APP=
       AC_MSG_WARN([No (usable) OpenSSL found, skipping ssl, ssh and crypto applications])

       for a in ssl crypto ssh; do
           echo "No usable OpenSSL found" > $ERL_TOP/lib/$a/SKIP
       done
    fi
else
    # Option given with PATH to package
    if test ! -d "$with_ssl" ; then
       AC_MSG_ERROR(Invalid path to option --with-ssl=PATH)
    fi
    SSL_ROOT="$with_ssl"
    if test "x$MIXED_CYGWIN" = "xyes" -a -d "$with_ssl/lib/VC"; then
	SSL_LIBDIR="$with_ssl/lib/VC"
    else
	SSL_LIBDIR="$with_ssl/lib"
    fi
    SSL_INCLUDE="-I$with_ssl/include"
    OPENSSL_CMD="$with_ssl/bin/openssl"
    SSL_APP=ssl
    CRYPTO_APP=crypto
    SSH_APP=ssh
fi

if test "x$SSL_APP" != "x" ; then
    dnl We found openssl, now check if we use kerberos 5 support
    AC_MSG_CHECKING(for OpenSSL kerberos 5 support)
    old_CPPFLAGS=$CPPFLAGS
    CPPFLAGS=$SSL_INCLUDE
    AC_EGREP_CPP(yes,[
#include <openssl/opensslconf.h>
#ifndef OPENSSL_NO_KRB5
  yes
#endif
      ],[
      AC_MSG_RESULT([yes])
      ssl_krb5_enabled=yes
      ],[
      AC_MSG_RESULT([no])
      ssl_krb5_enabled=no
      ])
    CPPFLAGS=$old_CPPFLAGS
    SSL_KRB5_INCLUDE=
    if test "x$ssl_krb5_enabled" = "xyes" ; then
        AC_MSG_CHECKING(for krb5.h in standard locations)
	for dir in $extra_dir $SSL_ROOT/include $SSL_ROOT/include/openssl \
		$SSL_ROOT/include/kerberos /cygdrive/c/kerberos/include \
		/usr/local/kerberos/include /usr/kerberos/include
	do
            if test -f "$dir/krb5.h" ; then
                SSL_KRB5_INCLUDE="$dir"
		break
            fi
        done
        if test "x$SSL_KRB5_INCLUDE" = "x" ; then
	    AC_MSG_RESULT([not found])
	    SSL_APP=
	    CRYPTO_APP=
	    SSH_APP=
	    AC_MSG_WARN([OpenSSL is configured for kerberos but no krb5.h found])
	    for a in ssl crypto ssh ; do
	 	echo "OpenSSL is configured for kerberos but no krb5.h found" > $ERL_TOP/lib/$a/SKIP
	    done
        else
            AC_MSG_RESULT([found in $SSL_KRB5_INCLUDE])
            SSL_INCLUDE="$SSL_INCLUDE -I$SSL_KRB5_INCLUDE"
        fi
    fi
fi

#--------------------------------------------------------------------
# Os mon stuff.
#--------------------------------------------------------------------
AC_SUBST(os_mon_programs)
AC_CHECK_LIB(kstat, kstat_open, [os_mon_programs="$os_mon_programs cpu_sup"])
case $host_os in
	solaris2*)
		os_mon_programs="$os_mon_programs ferrule mod_syslog" ;;
esac


dnl
dnl Then there are a number of apps which needs a java compiler...
dnl
need_java="jinterface ic/java_src orber/java_src
	   mnesia_session/examples/person/java_session"

# Remove all SKIP files from previous runs
for a in $need_java ; do
  /bin/rm -f $ERL_TOP/lib/$a/SKIP
done

AC_CHECK_PROGS(JAVAC, javac.sh javac guavac gcj jikes bock)
if test -n "$JAVAC"; then
  dnl Make sure it's at least JDK 1.2
  AC_CACHE_CHECK(for JDK version 1.2, 
     ac_cv_prog_javac_ver_1_2,
     [ERL_TRY_LINK_JAVA([], [java.util.Iterator iter;],
        ac_cv_prog_javac_ver_1_2=yes, ac_cv_prog_javac_ver_1_2=no)])
  if test $ac_cv_prog_javac_ver_1_2 = no; then
    unset -v JAVAC
  fi
fi
if test -z "$JAVAC"; then
  AC_MSG_WARN([Could not find any usable java compiler, will skip: jinterface])

  for a in $need_java ; do
	echo "No Java compiler found" > $ERL_TOP/lib/$a/SKIP
  done
fi

dnl
dnl Orber has a c++ example, this isn't the right way to check for
dnl it, but....
dnl
CXXFLAGS=
AC_SUBST(CXXFLAGS)
dnl this deliberately does not believe that 'gcc' is a C++ compiler
AC_CHECK_PROGS(CXX, $CCC c++ g++ CC cxx cc++ cl, false)

# Remove SKIP file from previous run
/bin/rm -f $ERL_TOP/lib/orber/SKIP

if test "$CXX" = false; then
  echo "No C++ compiler found" > $ERL_TOP/lib/orber/SKIP
fi

dnl ----------------------------------------------------------------------
dnl Include CPPFLAGS in CFLAGS
dnl ----------------------------------------------------------------------
CFLAGS="$CFLAGS $CPPFLAGS"

#
# Currently if we compile for 64 bits we want to compile
# some external port programs using 32 bits
#

# If not defined we trust the C compiler in $CC to do 32 bits
if test -z "$CC32"; then
  CC32="$CC"
fi

if test -z "$CFLAGS32"; then
  if test $ac_cv_sizeof_void_p != 4; then
    # We are compiling default 64 bits and use -m32 for 32 bit compilations
    CFLAGS32="$CFLAGS -m32"
  else
    CFLAGS32="$CFLAGS"
  fi
fi

AC_SUBST(CC32)
AC_SUBST(CFLAGS32)

dnl ----------------------------------------------------------------------
dnl Directories needed for the build
dnl ----------------------------------------------------------------------

erts=${erl_top}/erts

erts_dirs="								
  $erts/obj $erts/obj.debug
									
  $erts/obj/$host
  $erts/obj.debug/$host

"
for d in ${erl_top}/bin ${erl_top}/bin/$host $erts_dirs ;
do
  if test ! -d $d; then
    mkdir -p 1>/dev/null 2>&1 $d
  fi
done


dnl ----------------------------------------------------------------------
dnl Output the result.
dnl ----------------------------------------------------------------------

dnl  Note that the output files are relative to $srcdir

AC_OUTPUT(
  emulator/$host/Makefile:emulator/Makefile.in
  emulator/zlib/$host/Makefile:emulator/zlib/Makefile.in
  epmd/src/$host/Makefile:epmd/src/Makefile.in
  etc/common/$host/Makefile:etc/common/Makefile.in
  include/internal/$host/ethread.mk:include/internal/ethread.mk.in
  lib_src/$host/Makefile:lib_src/Makefile.in
  Makefile:Makefile.in
  ../make/$host/otp.mk:../make/otp.mk.in
dnl
dnl The ones below should be moved to their respective lib
dnl
  ../lib/ic/c_src/$host/Makefile:../lib/ic/c_src/Makefile.in
  ../lib/os_mon/c_src/$host/Makefile:../lib/os_mon/c_src/Makefile.in
  ../lib/ssl/c_src/$host/Makefile:../lib/ssl/c_src/Makefile.in
  ../lib/ssl/examples/certs/$host/Makefile:../lib/ssl/examples/certs/Makefile.in
  ../lib/crypto/c_src/$host/Makefile:../lib/crypto/c_src/Makefile.in
  ../lib/orber/c_src/$host/Makefile:../lib/orber/c_src/Makefile.in
  ../lib/runtime_tools/c_src/$host/Makefile:../lib/runtime_tools/c_src/Makefile.in
  ../lib/tools/c_src/$host/Makefile:../lib/tools/c_src/Makefile.in
  ../lib/asn1/c_src/$host/Makefile:../lib/asn1/c_src/Makefile.in
  )
    
